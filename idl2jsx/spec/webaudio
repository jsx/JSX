<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
      "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
  <title>Web Audio API</title>
  <meta name="revision"
  content="$Id: Overview.html,v 1.4 2012/07/30 11:44:57 tmichel Exp $" />
  <link rel="stylesheet" href="style.css" type="text/css" />
  <!--
          <script src="section-links.js" type="application/ecmascript"></script> 
          <script src="dfn.js" type="application/ecmascript"></script> 
          -->
  <!--[if IE]>
          <style type='text/css'>
            .ignore {
              -ms-filter:"progid:DXImageTransform.Microsoft.Alpha(Opacity=50)";
              filter: alpha(opacity=50);
            }
          </style>
          <![endif]-->
  <link rel="stylesheet" href="//www.w3.org/StyleSheets/TR/W3C-ED"
  type="text/css" />
</head>

<body>

<div class="head">
<p><a href="http://www.w3.org/"><img width="72" height="48" alt="W3C"
src="http://www.w3.org/Icons/w3c_home" /></a> </p>

<h1 id="title" class="title">Web Audio API </h1>

<h2 id="w3c-date-document"><acronym
title="World Wide Web Consortium">W3C</acronym> Editor's Draft
</h2>
<dl>
  <dt>This version: </dt>
    <dd><a
    href="https://dvcs.w3.org/hg/audio/raw-file/tip/webaudio/specification.html">https://dvcs.w3.org/hg/audio/raw-file/tip/webaudio/specification.html</a>
    </dd>
  <dt>Latest published version: </dt>
    <dd><a
      href="http://www.w3.org/TR/webaudio/">http://www.w3.org/TR/webaudio/</a>
    </dd>
  <dt>Previous version: </dt>
     <dd><a
      href="http://www.w3.org/TR/2012/WD-webaudio-20120315/">http://www.w3.org/TR/2012/WD-webaudio-20120315/</a>
    </dd>
</dl>

<dl>
  <dt>Editor: </dt>
    <dd>Chris Rogers, Google &lt;crogers@google.com&gt;</dd>
</dl>

<p class="copyright"><a
href="http://www.w3.org/Consortium/Legal/ipr-notice#Copyright">Copyright</a> ©
2012 <a href="http://www.w3.org/"><acronym
title="World Wide Web Consortium">W3C</acronym></a><sup>®</sup> (<a
href="http://www.csail.mit.edu/"><acronym
title="Massachusetts Institute of Technology">MIT</acronym></a>, <a
href="http://www.ercim.eu/"><acronym
title="European Research Consortium for Informatics and Mathematics">ERCIM</acronym></a>,
<a href="http://www.keio.ac.jp/">Keio</a>), All Rights Reserved. W3C <a
href="http://www.w3.org/Consortium/Legal/ipr-notice#Legal_Disclaimer">liability</a>,
<a
href="http://www.w3.org/Consortium/Legal/ipr-notice#W3C_Trademarks">trademark</a>
and <a href="http://www.w3.org/Consortium/Legal/copyright-documents">document
use</a> rules apply.</p>
<hr />
</div>

<div id="abstract-section" class="section">
<h2 id="abstract">Abstract</h2>

<p>This specification describes a high-level JavaScript <acronym
title="Application Programming Interface">API</acronym> for processing and
synthesizing audio in web applications. The primary paradigm is of an audio
routing graph, where a number of <a
href="#AudioNode-section"><code>AudioNode</code></a> objects are connected
together to define the overall audio rendering. The actual processing will
primarily take place in the underlying implementation (typically optimized
Assembly / C / C++ code), but <a href="#JavaScriptProcessing-section">direct
JavaScript processing and synthesis</a> is also supported. </p>

<p>The <a href="#introduction">introductory</a> section covers the motivation
behind this specification.</p>

<p>This API is designed to be used in conjunction with other APIs and elements
on the web platform, notably: XMLHttpRequest
(using the <code>responseType</code> and <code>response</code> attributes). For
games and interactive applications, it is anticipated to be used with the
<code>canvas</code> 2D and WebGL 3D graphics APIs. </p>
</div>

<div id="sotd-section" class="section">
<h2 id="sotd">Status of this Document</h2>


<p><em>This section describes the status of this document at the time of its
publication. Other documents may supersede this document. A list of current W3C
publications and the latest revision of this technical report can be found in
the <a href="http://www.w3.org/TR/">W3C technical reports index</a> at
http://www.w3.org/TR/. </em></p>

<p>This is the Editor's Draft of the <cite>Web Audio API</cite>
specification. It has been produced by the <a
href="http://www.w3.org/2011/audio/"><b>W3C Audio Working Group</b></a> , which
is part of the W3C WebApps Activity.</p>

<p></p>

<p>Please send comments about this document to &lt;<a
href="mailto:public-audio@w3.org">public-audio@w3.org</a>&gt; (<a
href="http://lists.w3.org/Archives/Public/public-audio/">public archives</a> of
the W3C audio mailing list). Web content and browser developers are encouraged
to review this draft. </p>

<p>Publication as a Working Draft does not imply endorsement by the W3C
Membership. This is a draft document and may be updated, replaced or obsoleted
by other documents at any time. It is inappropriate to cite this document as
other than work in progress.</p>

<p> This document was produced by a group operating under the <a href="http://www.w3.org/Consortium/Patent-Policy-20040205/">5 February 2004 W3C Patent Policy</a>. W3C maintains a <a rel="disclosure" href="http://www.w3.org/2004/01/pp-impl/46884/status">public list of any patent disclosures</a> made in connection with the deliverables of the group; that page also includes instructions for disclosing a patent. An individual who has actual knowledge of a patent which the individual believes contains <a href="http://www.w3.org/Consortium/Patent-Policy-20040205/#def-essential">Essential Claim(s)</a> must disclose the information in accordance with <a href="http://www.w3.org/Consortium/Patent-Policy-20040205/#sec-Disclosure">section 6 of the W3C Patent Policy</a>. </p>
</div>

<div id="toc">
<h2 id="L13522">Table of Contents</h2>

<div class="toc">
<ul>
  <li><a href="#introduction">1. Introduction</a>
    <ul>
      <li><a href="#Features">1.1. Features</a></li>
      <li><a href="#ModularRouting">1.2. Modular Routing</a></li>
      <li><a href="#APIOverview">1.3. API Overview</a></li>
    </ul>
  </li>
  <li><a href="#conformance">2. Conformance</a></li>
  <li><a href="#terminology">3. Terminology and Algorithms</a></li>
  <li><a href="#API-section">4. The Audio API</a>
    <ul>
      <li><a href="#AudioContext-section">4.1. The AudioContext Interface</a> 
        <ul>
          <li><a href="#attributes-AudioContext">4.1.1. Attributes</a></li>
          <li><a href="#methodsandparams-AudioContext">4.1.2. Methods and
            Parameters</a></li>
          <li><a href="#lifetime-AudioContext">4.1.3. Lifetime</a></li>
        </ul>
      </li>
      <li><a href="#AudioNode-section">4.2. The AudioNode Interface</a> 
        <ul>
          <li><a href="#attributes-AudioNode">4.2.1. Attributes</a></li>
          <li><a href="#methodsandparams-AudioNode">4.2.2. Methods and
            Parameters</a></li>
          <li><a href="#lifetime-AudioNode">4.2.3. Lifetime</a></li>
        </ul>
      </li>
      <li><a href="#AudioSourceNode">4.3. The AudioSourceNode Interface</a></li>
      <li><a href="#AudioDestinationNode">4.4. The AudioDestinationNode
        Interface</a> 
        <ul>
          <li><a href="#attributes-AudioDestinationNode">4.4.1. Attributes</a></li>
        </ul>
      </li>
      <li><a href="#AudioParam">4.5. The AudioParam Interface</a> 
        <ul>
          <li><a href="#attributes-AudioParam">4.5.1. Attributes</a></li>
          <li><a href="#methodsandparams-AudioParam">4.5.2. Methods and
            Parameters</a></li>
          <li><a href="#AudioGain-section">4.6. AudioGain</a></li>
        </ul>
      </li>
      <li><a href="#AudioGainNode">4.7. The AudioGainNode Interface</a> 
        <ul>
          <li><a href="#attributes-AudioGainNode">4.7.1. Attributes</a></li>
        </ul>
      </li>
      <li><a href="#DelayNode">4.8. The DelayNode Interface</a> 
        <ul>
          <li><a href="#attributes-AudioGainNode_2">4.8.1. Attributes</a></li>
        </ul>
      </li>
      <li><a href="#AudioBuffer">4.9. The AudioBuffer Interface</a> 
        <ul>
          <li><a href="#attributes-AudioBuffer">4.9.1. Attributes</a></li>
          <li><a href="#methodsandparams-AudioBuffer">4.9.2. Methods and
            Parameters</a></li>
        </ul>
      </li>
      <li><a href="#AudioBufferSourceNode">4.10. The AudioBufferSourceNode
        Interface</a> 
        <ul>
          <li><a href="#attributes-AudioBufferSourceNode">4.10.1.
          Attributes</a></li>
          <li><a href="#methodsandparams-AudioBufferSourceNode">4.10.2. Methods and
            Parameters</a></li>
        </ul>
      </li>
      <li><a href="#MediaElementAudioSourceNode">4.11. The
        MediaElementAudioSourceNode Interface</a></li>
      <li><a href="#JavaScriptAudioNode">4.12. The JavaScriptAudioNode
        Interface</a> 
        <ul>
          <li><a href="#attributes-JavaScriptAudioNode">4.12.1. Attributes</a></li>
        </ul>
      </li>
      <li><a href="#AudioProcessingEvent">4.13. The AudioProcessingEvent
        Interface</a> 
        <ul>
          <li><a href="#attributes-AudioProcessingEvent">4.13.1. Attributes</a></li>
        </ul>
      </li>
      <li><a href="#AudioPannerNode">4.14. The AudioPannerNode Interface</a> 
        <ul>
          <li><a href="#AudioPannerNode-sub">4.14.1. Constants</a></li>
          <li><a href="#attributes-AudioPannerNode_attributes">4.14.2.
            Attributes</a></li>
          <li><a href="#Methods_and_Parameters">4.14.3. Methods and
          Parameters</a></li>
        </ul>
      </li>
      <li><a href="#AudioListener">4.15. The AudioListener Interface</a> 
        <ul>
          <li><a href="#attributes-AudioListener">4.15.1. Attributes</a></li>
          <li><a href="#L15842">4.15.2. Methods and Parameters</a></li>
        </ul>
      </li>
      <li><a href="#ConvolverNode">4.16. The ConvolverNode Interface</a> 
        <ul>
          <li><a href="#attributes-ConvolverNode">4.16.1. Attributes</a></li>
        </ul>
      </li>
      <li><a href="#RealtimeAnalyserNode">4.17. The RealtimeAnalyserNode
        Interface</a> 
        <ul>
          <li><a href="#attributes-ConvolverNode_2">4.17.1. Attributes</a></li>
          <li><a href="#methods-and-parameters">4.17.2. Methods and
          Parameters</a></li>
        </ul>
      </li>
      <li><a href="#AudioChannelSplitter">4.18. The AudioChannelSplitter
        Interface</a> 
        <ul>
          <li><a href="#example-1">Example:</a></li>
        </ul>
      </li>
      <li><a href="#AudioChannelMerger">4.19. The AudioChannelMerger Interface</a> 
        <ul>
          <li><a href="#example-2">Example:</a></li>
        </ul>
      </li>
      <li><a href="#DynamicsCompressorNode">4.20. The DynamicsCompressorNode
        Interface</a> 
        <ul>
          <li><a href="#attributes-DynamicsCompressorNode">4.20.1.
          Attributes</a></li>
        </ul>
      </li>
      <li><a href="#BiquadFilterNode">4.21. The BiquadFilterNode Interface</a> 
        <ul>
          <li><a href="#BiquadFilterNode-description">4.21.1 Lowpass</a></li>
          <li><a href="#HIGHPASS">4.21.2 Highpass</a></li>
          <li><a href="#BANDPASS">4.21.3 Bandpass</a></li>
          <li><a href="#LOWSHELF">4.21.4 Lowshelf</a></li>
          <li><a href="#L16352">4.21.5 Highshelf</a></li>
          <li><a href="#PEAKING">4.21.6 Peaking</a></li>
          <li><a href="#NOTCH">4.21.7 Notch</a></li>
          <li><a href="#ALLPASS">4.21.8 Allpass</a></li>
          <li><a href="#Methods">4.21.9. Methods</a></li>
        </ul>
      </li>
      <li><a href="#WaveShaperNode">4.22. The WaveShaperNode Interface</a> 
        <ul>
          <li><a href="#attributes-WaveShaperNode">4.22.1.
            Attributes</a></li>
        </ul>
      </li>
      <li><a href="#Oscillator">4.23. The Oscillator Interface</a> 
        <ul>
          <li><a href="#attributes-Oscillator">4.23.1.
            Attributes</a></li>
            <li><a href="#methodsandparams-Oscillator-section">4.23.2. Methods and
            Parameters</a></li>
        </ul>
      </li>
      <li><a href="#WaveTable">4.24. The WaveTable Interface</a> 
      </li>
      <li><a href="#MediaStreamAudioSourceNode">4.25. The
        MediaStreamAudioSourceNode Interface</a></li>
    </ul>
  </li>
  <li><a href="#AudioElementIntegration">5. Integration with the
    <code>audio</code> and <code>video</code> elements</a></li>
  <li><a href="#MixerGainStructure">6. Mixer Gain Structure</a> 
    <ul>
      <li><a href="#background">Background</a></li>
      <li><a href="#SummingJunction">Summing Inputs</a></li>
      <li><a href="#gain-Control">Gain Control</a></li>
      <li><a href="#Example-mixer-with-send-busses">Example: Mixer with Send
        Busses</a></li>
    </ul>
  </li>
  <li><a href="#DynamicLifetime">7. Dynamic Lifetime</a> 
    <ul>
      <li><a href="#DynamicLifetime-background">Background</a></li>
      <li><a href="#Example-DynamicLifetime">Example</a></li>
    </ul>
  </li>
  <li><a href="#ChannelLayouts">8. Channel Layouts</a></li>
  <li><a href="#UpMix">9. Channel up-mixing and down-mixing</a> 
    <ul>
      <li><a href="#UpMix-sub">Up Mixing</a></li>
      <li><a href="#down-mix">Down Mixing</a></li>
    </ul>
  </li>
  <li><a href="#EventScheduling">10. Event Scheduling</a></li>
  <li><a href="#Spatialization">11. Spatialization / Panning </a> 
    <ul>
      <li><a href="#Spatialization-background">Background</a></li>
      <li><a href="#Spatialization-panning-algorithm">Panning Algorithm</a></li>
      <li><a href="#Spatialization-distance-effects">Distance Effects</a></li>
      <li><a href="#Spatialization-sound-cones">Sound Cones</a></li>
      <li><a href="#Spatialization-doppler-shift">Doppler Shift</a></li>
    </ul>
  </li>
  <li><a href="#Convolution">12. Linear Effects using Convolution</a> 
    <ul>
      <li><a href="#Convolution-background">Background</a></li>
      <li><a href="#Convolution-motivation">Motivation for use as a
      Standard</a></li>
      <li><a href="#Convolution-implementation-guide">Implementation Guide</a></li>
      <li><a href="#Convolution-reverb-effect">Reverb Effect (with
        matrixing)</a></li>
      <li><a href="#recording-impulse-responses">Recording Impulse
      Responses</a></li>
      <li><a href="#tools">Tools</a></li>
      <li><a href="#recording-setup">Recording Setup</a></li>
      <li><a href="#warehouse">The Warehouse Space</a></li>
    </ul>
  </li>
  <li><a href="#JavaScriptProcessing">13. JavaScript Synthesis and
    Processing</a> 
    <ul>
      <li><a href="#custom-DSP-effects">Custom DSP Effects</a></li>
      <li><a href="#educational-applications">Educational Applications</a></li>
      <li><a href="#javaScript-performance">JavaScript Performance</a></li>
    </ul>
  </li>
  <li><a href="#RealtimeAnalysis">14. Realtime Analysis</a></li>
  <li><a href="#Performance">15. Performance Considerations</a> 
    <ul>
      <li><a href="#Latency">15.1. Latency: What it is and Why it's
        Important</a></li>
      <li><a href="#audio-glitching">15.2. Audio Glitching</a></li>
      <li><a href="#hardware-scalability">15.3. Hardware Scalability</a> 
        <ul>
          <li><a href="#CPU-monitoring">15.3.1. CPU monitoring</a></li>
          <li><a href="#Voice-dropping">15.3.2. Voice Dropping</a></li>
          <li><a href="#Simplification-of-Effects-Processing">15.3.3.
            Simplification of Effects Processing</a></li>
          <li><a href="#Sample-rate">15.3.4. Sample Rate</a></li>
          <li><a href="#pre-flighting">15.3.5. Pre-flighting</a></li>
          <li><a href="#Authoring-for-different-user-agents">15.3.6. Authoring
            for different user agents</a></li>
          <li><a href="#Scalability-of-Direct-JavaScript-Synthesis">15.3.7.
            Scalability of Direct JavaScript Synthesis / Processing</a></li>
        </ul>
      </li>
      <li><a href="#JavaScriptPerformance">15.4. JavaScript Issues with
        real-time Processing and Synthesis: </a></li>
    </ul>
  </li>
  <li><a href="#ExampleApplications">16. Example Applications</a> 
    <ul>
      <li><a href="#basic-sound-playback">Basic Sound Playback</a></li>
      <li><a href="#threeD-environmentse-and-games">3D Environments and
        Games</a></li>
      <li><a href="#musical-applications">Musical Applications</a></li>
      <li><a href="#music-visualizers">Music Visualizers</a></li>
      <li><a href="#educational-applications_2">Educational
      Applications</a></li>
      <li><a href="#artistic-audio-exploration">Artistic Audio
      Exploration</a></li>
    </ul>
  </li>
  <li><a href="#SecurityConsiderations">17. Security Considerations</a></li>
  <li><a href="#PrivacyConsiderations">18. Privacy Considerations</a></li>
  <li><a href="#requirements">19. Requirements and Use Cases</a></li>
  <li><a href="#L17310">A.References</a> 
    <ul>
      <li><a href="#Normative-references">A.1 Normative references</a></li>
      <li><a href="#Informative-references">A.2 Informative references</a></li>
    </ul>
  </li>
  <li><a href="#L17335">B.Acknowledgements</a></li>
  <li><a href="#ChangeLog">C. Web Audio API Change Log</a></li>
</ul>
</div>
</div>

<div id="sections">

<div id="div-introduction" class="section">
<h2 id="introduction">1. Introduction</h2>

<p class="norm">This section is informative.</p>

<p>Audio on the web has been fairly primitive up to this point and until very
recently has had to be delivered through plugins such as Flash and QuickTime.
The introduction of the <code>audio</code> element in HTML5 is very important,
allowing for basic streaming audio playback. But, it is not powerful enough to
handle more complex audio applications. For sophisticated web-based games or
interactive applications, another solution is required. It is a goal of this
specification to include the capabilities found in modern game audio engines as
well as some of the mixing, processing, and filtering tasks that are found in
modern desktop audio production applications. </p>

<p>The APIs have been designed with a wide variety of <a
href="#ExampleApplications-section">use cases</a> in mind. Ideally, it should
be able to support <i>any</i> use case which could reasonably be implemented
with an optimized C++ engine controlled via JavaScript and run in a browser.
That said, modern desktop audio software can have very advanced capabilities,
some of which would be difficult or impossible to build with this system.
Apple's Logic Audio is one such application which has support for external MIDI
controllers, arbitrary plugin audio effects and synthesizers, highly optimized
direct-to-disk audio file reading/writing, tightly integrated time-stretching,
and so on. Nevertheless, the proposed system will be quite capable of
supporting a large range of reasonably complex games and interactive
applications, including musical ones. And it can be a very good complement to
the more advanced graphics features offered by WebGL. The API has been designed
so that more advanced capabilities can be added at a later time. </p>

<div id="Features-section" class="section">
<h2 id="Features">1.1. Features</h2>
</div>

<p>The API supports these primary features: </p>
<ul>
  <li><a href="#ModularRouting-section">Modular routing</a> for simple or
    complex mixing/effect architectures, including <a
    href="#MixerGainStructure-section">multiple sends and submixes</a>.</li>
  <li><a href="#EventScheduling-section">Sample-accurate scheduled sound
    playback</a> with low <a href="#Latency-section">latency</a> for musical
    applications requiring a very high degree of rhythmic precision such as
    drum machines and sequencers. This also includes the possibility of <a
    href="#DynamicLifetime-section">dynamic creation</a> of effects. </li>
  <li>Automation of audio parameters for envelopes, fade-ins / fade-outs,
    granular effects, filter sweeps, LFOs etc. </li>
  <li>Processing of audio sources from an <code>audio</code> or
    <code>video</code> <a href="#AudioElementIntegration-section">media
    element</a>. </li>
  <li>Audio stream synthesis and processing <a
    href="#JavaScriptProcessing-section">directly in JavaScript</a>. </li>
  <li><a href="#Spatialization-section">Spatialized audio</a> supporting a wide
    range of 3D games and immersive environments: 
    <ul>
      <li>Panning models: equal-power, HRTF, sound-field, pass-through </li>
      <li>Distance Attenuation </li>
      <li>Sound Cones </li>
      <li>Obstruction / Occlusion </li>
      <li>Doppler Shift </li>
      <li>Source / Listener based</li>
    </ul>
  </li>
  <li>A <a href="#Convolution-section">convolution engine</a> for a wide range
    of linear effects, especially very high-quality room effects. Here are some
    examples of possible effects: 
    <ul>
      <li>Small / large room </li>
      <li>Cathedral </li>
      <li>Concert hall </li>
      <li>Cave </li>
      <li>Tunnel </li>
      <li>Hallway </li>
      <li>Forest </li>
      <li>Amphitheater </li>
      <li>Sound of a distant room through a doorway </li>
      <li>Extreme filters</li>
      <li>Strange backwards effects</li>
      <li>Extreme comb filter effects </li>
    </ul>
  </li>
  <li>Dynamics compression for overall control and sweetening of the mix </li>
  <li>Efficient <a href="#RealtimeAnalysis-section">real-time time-domain and
    frequency analysis / music visualizer support</a></li>
  <li>Efficient biquad filters for lowpass, highpass, and other common filters.
  </li>
  <li>A Waveshaping effect for distortion and other non-linear effects</li>
</ul>

<div id="ModularRouting-section">
<h2 id="ModularRouting">1.2. Modular Routing</h2>

<p>Modular routing allows arbitrary connections between different <a
href="#AudioNode-section"><code>AudioNode</code></a> objects. Each node can
have inputs and/or outputs. An <a
href="#AudioSourceNode-section"><code>AudioSourceNode</code></a> has no inputs
and a single output. An <a
href="#AudioDestinationNode-section"><code>AudioDestinationNode</code></a> has
one input and no outputs and represents the final destination to the audio
hardware. Other nodes such as filters can be placed between the <a
href="#AudioSourceNode-section"><code>AudioSourceNode</code></a> nodes and the
final <a
href="#AudioDestinationNode-section"><code>AudioDestinationNode</code></a>
node. The developer doesn't have to worry about low-level stream format details
when two objects are connected together; <a href="#UpMix-section">the right
thing just happens</a>. For example, if a mono audio stream is connected to a
stereo input it should just mix to left and right channels <a
href="#UpMix-section">appropriately</a>. </p>

<p>In the simplest case, a single source can be routed directly to the output.
All routing occurs within an <a
href="#AudioContext-section"><code>AudioContext</code></a> containing a single
<a href="#AudioDestinationNode-section"><code>AudioDestinationNode</code></a>:
</p>
<img alt="modular routing" src="images/modular-routing1.png" /> 

<p>Illustrating this simple routing, here's a simple example playing a single
sound: </p>

<div class="block">

<div class="blockTitleDiv">
<span class="blockTitle">ECMAScript</span> </div>

<div class="blockContent">
<pre class="code"><code class="es-code"> 

            var context = new AudioContext();

            function playSound() {
                var source = context.createBufferSource();
                source.buffer = dogBarkingBuffer;
                source.connect(context.destination);
                source.noteOn(0);
            }
                    </code></pre>
</div>
</div>

<p>Here's a more complex example with three sources and a convolution reverb
send with a dynamics compressor at the final output stage: </p>
<img alt="modular routing2" src="images/modular-routing2.png" /> 

<p><span class="ednote">TODO: add Javascript example code here ... </span></p>
</div>

<div id="APIOverview-section" class="section">
<h2 id="APIOverview">1.3. API Overview</h2>
</div>

<p>The interfaces defined are: </p>
<ul>
  <li>An <a class="dfnref" href="#AudioContext-section">AudioContext</a>
    interface, which contains an audio signal graph representing connections
    betweens AudioNodes. </li>
  <li>An <a class="dfnref" href="#AudioNode-section">AudioNode</a> interface,
    which represents audio sources, audio outputs, and intermediate processing
    modules. AudioNodes can be dynamically connected together in a <a
    href="#ModularRouting-section">modular fashion</a>. <code>AudioNodes</code>
    exist in the context of an <code>AudioContext</code> </li>
  <li>An <a class="dfnref" href="#AudioSourceNode-section">AudioSourceNode</a>
    interface, an abstract AudioNode subclass representing a node which
    generates audio. </li>
  <li>An <a class="dfnref"
    href="#AudioDestinationNode-section">AudioDestinationNode</a> interface, an
    AudioNode subclass representing the final destination for all rendered
    audio. </li>
  <li>An <a class="dfnref" href="#AudioBuffer-section">AudioBuffer</a>
    interface, for working with memory-resident audio assets. These can
    represent one-shot sounds, or longer audio clips. </li>
  <li>An <a class="dfnref"
    href="#AudioBufferSourceNode-section">AudioBufferSourceNode</a> interface,
    an AudioNode which generates audio from an AudioBuffer. </li>
  <li>A <a class="dfnref"
    href="#MediaElementAudioSourceNode-section">MediaElementAudioSourceNode</a>
    interface, an AudioNode which is the audio source from an
    <code>audio</code>, <code>video</code>, or other media element. </li>
  <li>A <a class="dfnref"
    href="#JavaScriptAudioNode-section">JavaScriptAudioNode</a> interface, an
    AudioNode for generating or processing audio directly in JavaScript. </li>
  <li>An <a class="dfnref"
    href="#AudioProcessingEvent-section">AudioProcessingEvent</a> interface,
    which is an event type used with <code>JavaScriptAudioNode</code> objects.
  </li>
  <li>An <a class="dfnref" href="#AudioParam-section">AudioParam</a> interface,
    for controlling an individual aspect of an AudioNode's functioning, such as
    volume. </li>
  <li>An <a class="dfnref" href="#AudioGainNode-section">AudioGainNode</a>
    interface, for explicit gain control. Because inputs to AudioNodes support
    multiple connections (as a unity-gain summing junction), mixers can be <a
    href="#MixerGainStructure-section">easily built</a> with AudioGainNodes.
  </li>
  <li>A <a class="dfnref" href="#BiquadFilterNode-section">BiquadFilterNode</a>
    interface, an AudioNode for common low-order filters such as: 
    <ul>
      <li>Low Pass</li>
      <li>High Pass </li>
      <li>Band Pass </li>
      <li>Low Shelf </li>
      <li>High Shelf </li>
      <li>Peaking </li>
      <li>Notch </li>
      <li>Allpass </li>
    </ul>
  </li>
  <li>A <a class="dfnref" href="#DelayNode-section">DelayNode</a> interface, an
    AudioNode which applies a dynamically adjustable variable delay. </li>
  <li>An <a class="dfnref" href="#AudioPannerNode-section">AudioPannerNode</a>
    interface, for spatializing / positioning audio in 3D space. </li>
  <li>An <a class="dfnref" href="#AudioListener-section">AudioListener</a>
    interface, which works with an <code>AudioPannerNode</code> for
    spatialization. </li>
  <li>A <a class="dfnref" href="#ConvolverNode-section">ConvolverNode</a>
    interface, an AudioNode for applying a <a
    href="#Convolution-section">real-time linear effect</a> (such as the sound
    of a concert hall). </li>
  <li>A <a class="dfnref"
    href="#RealtimeAnalyserNode-section">RealtimeAnalyserNode</a> interface,
    for use with music visualizers, or other visualization applications. </li>
  <li>A <a class="dfnref"
    href="#AudioChannelSplitter-section">AudioChannelSplitter</a> interface,
    for accessing the individual channels of an audio stream in the routing
    graph. </li>
  <li>A <a class="dfnref"
    href="#AudioChannelMerger-section">AudioChannelMerger</a> interface, for
    combining channels from multiple audio streams into a single audio stream.
  </li>
  <li>A DynamicsProcessorNode interface, an 
    AudioNode for dynamic-shaping (compressor / expander) effects. </li>
  <li>A <a class="dfnref" href="#dfn-WaveShaperNode">WaveShaperNode</a>
    interface, an AudioNode which applies a non-linear waveshaping effect for
    distortion and other more subtle warming effects. </li>
</ul>
</div>
</div>

<div id="conformance-section" class="section">
<h2 id="conformance">2. Conformance</h2>

<p>Everything in this specification is normative except for examples and
sections marked as being informative. </p>

<p>The keywords “<span class="rfc2119">MUST</span>”, “<span
class="rfc2119">MUST NOT</span>”, “<span
class="rfc2119">REQUIRED</span>”, “<span class="rfc2119">SHALL</span>”,
“<span class="rfc2119">SHALL NOT</span>”, “<span
class="rfc2119">RECOMMENDED</span>”, “<span class="rfc2119">MAY</span>”
and “<span class="rfc2119">OPTIONAL</span>” in this document are to be
interpreted as described in <cite><a href="http://www.ietf.org/rfc/rfc2119">Key
words for use in RFCs to Indicate Requirement Levels</a></cite> <a
href="#RFC2119">[RFC2119]</a>. </p>

<p>The following conformance classes are defined by this specification: </p>
<dl>
  <dt><dfn id="dfn-conforming-implementation">conforming
  implementation</dfn></dt>
    <dd><p>A user agent is considered to be a <a class="dfnref"
      href="#dfn-conforming-implementation">conforming implementation</a> if it
      satisfies all of the <span class="rfc2119">MUST</span>-, <span
      class="rfc2119">REQUIRED</span>- and <span
      class="rfc2119">SHALL</span>-level criteria in this specification that
      apply to implementations. </p>
    </dd>
</dl>
</div>

<div id="terminology-section" class="section">
<h2 id="terminology">3. Terminology and Algorithms</h2>

<p>This specification includes algorithms (steps) as part of the definition of
methods. Conforming implementations (referred to as "user agents" from here on)
MAY use other algorithms in the implementation of these methods, provided the
end result is the same.</p>
</div>

<div id="API-section-section" class="section">
<h2 id="API-section">4. The Audio API</h2>
</div>

<div id="AudioContext-section-section" class="section">
<h2 id="AudioContext-section">4.1. The AudioContext Interface</h2>

<p>This interface represents a set of <a
href="#AudioNode-section"><code>AudioNode</code></a> objects and their
connections. It allows for arbitrary routing of signals to the <a
href="#AudioDestinationNode-section"><code>AudioDestinationNode</code></a>
(what the user ultimately hears). Nodes are created from the context and are
then <a href="#ModularRouting-section">connected</a> together. In most use
cases, only a single AudioContext is used per document. An AudioContext is
constructed as follows: </p>
<pre>        var context = new AudioContext();
        </pre>
<br />


<div class="block">

<div class="blockTitleDiv">
<span class="blockTitle">Web IDL</span></div>

<div class="blockContent">
<pre class="code"><code class="idl-code">

callback AudioBufferCallback = void (AudioBuffer decodedData);

[Constructor]
interface <dfn id="dfn-AudioContext">AudioContext</dfn> {

    readonly attribute AudioDestinationNode destination;
    readonly attribute float sampleRate;
    readonly attribute float currentTime;
    readonly attribute AudioListener listener;
    readonly attribute unsigned long activeSourceCount;

    AudioBuffer createBuffer(unsigned long numberOfChannels, unsigned long length, float sampleRate);

    AudioBuffer createBuffer(ArrayBuffer buffer, boolean mixToMono);

    void decodeAudioData(ArrayBuffer audioData,
                         AudioBufferCallback successCallback,
                         optional AudioBufferCallback errorCallback);


    <span class="comment">// AudioNode creation </span>
    AudioBufferSourceNode createBufferSource();

    MediaElementAudioSourceNode createMediaElementSource(HTMLMediaElement mediaElement);

    MediaStreamAudioSourceNode createMediaStreamSource(MediaStream mediaStream);

    JavaScriptAudioNode createJavaScriptNode(unsigned long bufferSize,
                                             optional unsigned long numberOfInputChannels = 2,
                                             optional unsigned long numberOfOutputChannels = 2);

    RealtimeAnalyserNode createAnalyser();
    AudioGainNode createGainNode();
    DelayNode createDelayNode(optional double maxDelayTime);
    BiquadFilterNode createBiquadFilter();
    AudioPannerNode createPanner();
    ConvolverNode createConvolver();

    AudioChannelSplitter createChannelSplitter(optional unsigned long numberOfOutputs = 6);

    AudioChannelMerger createChannelMerger(optional unsigned long numberOfInputs = 6);

    DynamicsCompressorNode createDynamicsCompressor();

    Oscillator createOscillator();
    WaveTable createWaveTable(Float32Array real, Float32Array imag);

};
</code></pre>
</div>
</div>

<div id="attributes-AudioContext-section" class="section">
<h3 id="attributes-AudioContext">4.1.1. Attributes</h3>
<dl>
  <dt id="dfn-destination"><code>destination</code></dt>
    <dd><p>An <a
      href="#AudioDestinationNode-section"><code>AudioDestinationNode</code></a>
      with a single input representing the final destination for all audio (to
      be rendered to the audio hardware). All AudioNodes actively rendering
      audio will directly or indirectly connect to <code>destination</code>.</p>
    </dd>
</dl>
<dl>
  <dt id="dfn-sampleRate"><code>sampleRate</code></dt>
    <dd><p>The sample rate (in sample-frames per second) at which the
      AudioContext handles audio. It is assumed that all AudioNodes in the
      context run at this rate. In making this assumption, sample-rate
      converters or "varispeed" processors are not supported in real-time
      processing.</p>
    </dd>
</dl>
<dl>
  <dt id="dfn-currentTime"><code>currentTime</code></dt>
    <dd><p>This is a time in seconds which starts at zero when the context is
      created and increases in real-time. All scheduled times are relative to
      it. This is not a "transport" time which can be started, paused, and
      re-positioned. It is always moving forward. A GarageBand-like timeline
      transport system can be very easily built on top of this (in JavaScript).
      This time corresponds to an ever-increasing hardware timestamp. </p>
    </dd>
</dl>
<dl>
  <dt id="dfn-listener"><code>listener</code></dt>
    <dd><p>An <a href="#AudioListener-section"><code>AudioListener</code></a>
      which is used for 3D <a
      href="#Spatialization-section">spatialization</a>.</p>
    </dd>
</dl>
<dl>
  <dt id="dfn-activeSourceCount"><code>activeSourceCount</code></dt>
    <dd><p>The number of <a
      href="#AudioBufferSourceNode-section"><code>AudioBufferSourceNodes</code></a> that are currently playing.</p>
    </dd>
</dl>
</div>

<div id="methodsandparams-AudioContext-section" class="section">
<h3 id="methodsandparams-AudioContext">4.1.2. Methods and Parameters</h3>
<dl>
  <dt id="dfn-createBuffer">The <code>createBuffer</code> method</dt>
    <dd><p>Creates an AudioBuffer of the given size. The audio data in the
      buffer will be zero-initialized (silent).  An exception will be thrown if
      the <code>numberOfChannels</code> or <code>sampleRate</code> are out-of-bounds.</p>
      <p>The <dfn id="dfn-numberOfChannels">numberOfChannels</dfn> parameter
      determines how many channels the buffer will have.  An implementation must support at least 32 channels. </p>
      <p>The <dfn id="dfn-length">length</dfn> parameter determines the size of
      the buffer in sample-frames. </p>
      <p>The <dfn id="dfn-sampleRate_2">sampleRate</dfn> parameter describes
      the sample-rate of the linear PCM audio data in the buffer in
      sample-frames per second.  An implementation must support sample-rates in at least the range 22050 to 96000.</p>
    </dd>
</dl>
<dl>
  <dt id="dfn-createBuffer_2">The <code>createBuffer</code> from ArrayBuffer
  method</dt>
    <dd><p>Creates an AudioBuffer given the audio file data contained in the
      ArrayBuffer. The ArrayBuffer can, for example, be loaded from an
      XMLHttpRequest with the new <code>responseType</code> and
      <code>response</code> attributes.</p>
      <p>The <dfn id="dfn-buffer">buffer</dfn> parameter contains the audio
      file data (for example from a .wav file). </p>
      <p>The <dfn id="dfn-mixToMono">mixToMono</dfn> parameter determines if a
      mixdown to mono will be performed. Normally, this would not be set. </p>
    </dd>
</dl>
<dl>
  <dt id="dfn-decodeAudioData">The <code>decodeAudioData</code> method</dt>
    <dd><p>Asynchronously decodes the audio file data contained in the
      ArrayBuffer. The ArrayBuffer can, for example, be loaded from an
      XMLHttpRequest with the new <code>responseType</code> and
      <code>response</code> attributes. Audio file data can be in any of the
      formats supported by the <code>audio</code> element. </p>
      <p>The decodeAudioData() method is preferred over the createBuffer() from
      ArrayBuffer method because it is asynchronous and does not block the main
      JavaScript thread. </p>
      <p><dfn id="dfn-audioData">audioData</dfn> is an ArrayBuffer containing
      audio file data.</p>
      <p><dfn id="dfn-successCallback">successCallback</dfn> is a callback
      function which will be invoked when the decoding is finished. The single
      argument to this callback is an AudioBuffer representing the decoded PCM
      audio data.</p>
      <p><dfn id="dfn-errorCallback">errorCallback</dfn> is a callback function
      which will be invoked if there is an error decoding the audio file
      data.</p>
    </dd>
</dl>
<dl>
  <dt id="dfn-createBufferSource">The <code>createBufferSource</code>
  method</dt>
    <dd><p>Creates an <a
      href="#AudioBufferSourceNode-section"><code>AudioBufferSourceNode</code></a>.</p>
    </dd>
</dl>
<dl>
  <dt id="dfn-createMediaElementSource">The <code>createMediaElementSource</code>
  method</dt>
    <dd><p>Creates a <a
      href="#MediaElementAudioSourceNode-section"><code>MediaElementAudioSourceNode</code></a> given an HTMLMediaElement.
      As a consequence of calling this method, audio playback from the HTMLMediaElement will be re-routed
      into the processing graph of the AudioContext.</p>
    </dd>
</dl>
<dl>
  <dt id="dfn-createMediaStreamSource">The <code>createMediaStreamSource</code>
  method</dt>
    <dd><p>Creates a <a
      href="#MediaStreamAudioSourceNode-section"><code>MediaStreamAudioSourceNode</code></a> given a MediaStream.
      As a consequence of calling this method, audio playback from the MediaStream will be re-routed
      into the processing graph of the AudioContext.</p>
    </dd>
</dl>
<dl>
  <dt id="dfn-createJavaScriptNode">The <code>createJavaScriptNode</code>
  method</dt>
    <dd><p>Creates a <a
      href="#JavaScriptAudioNode"><code>JavaScriptAudioNode</code></a> for
      direct audio processing using JavaScript.  An exception will be thrown if <code>bufferSize</code> or <code>numberOfInputChannels</code> or <code>numberOfOutputChannels</code>
      are outside the valid range. </p>
      <p>The <dfn id="dfn-bufferSize">bufferSize</dfn> parameter determines the
      buffer size in units of sample-frames. It must be one of the following
      values: 256, 512, 1024, 2048, 4096, 8192, 16384. This value controls how
      frequently the <code>onaudioprocess</code> event handler is called and
      how many sample-frames need to be processed each call. Lower values for
      <code>bufferSize</code> will result in a lower (better) <a
      href="#Latency-section">latency</a>. Higher values will be necessary to
      avoid audio breakup and <a href="#Glitching-section">glitches</a>. The
      value chosen must carefully balance between latency and audio quality.
      </p>
      <p>The <dfn id="dfn-numberOfInputChannels">numberOfInputChannels</dfn> parameter (defaults to 2) and
      determines the number of channels for this node's input.  Values of up to 32 must be supported. </p>
      <p>The <dfn id="dfn-numberOfOutputChannels">numberOfOutputChannels</dfn> parameter (defaults to 2) and
      determines the number of channels for this node's output.  Values of up to 32 must be supported.</p>
      <p>It is invalid for both <code>numberOfInputChannels</code> and
      <code>numberOfOutputChannels</code> to be zero. </p>
    </dd>
</dl>
<dl>
  <dt id="dfn-createAnalyser">The <code>createAnalyser</code> method</dt>
    <dd><p>Creates a <a
      href="#RealtimeAnalyserNode-section"><code>RealtimeAnalyserNode</code></a>.</p>
    </dd>
</dl>
<dl>
  <dt id="dfn-createGainNode">The <code>createGainNode</code> method</dt>
    <dd><p>Creates an <a
      href="#AudioGainNode-section"><code>AudioGainNode</code></a>.</p>
    </dd>
</dl>
<dl>
  <dt id="dfn-createDelayNode">The <code>createDelayNode</code> method</dt>
    <dd><p>Creates a <a href="#DelayNode-section"><code>DelayNode</code></a>
      representing a variable delay line. The initial default delay time will
      be 0 seconds.</p>
      <p>The <dfn id="dfn-maxDelayTime">maxDelayTime</dfn> parameter is
      optional and specifies the maximum delay time allowed for the delay line.
      If not specified, the maximum delay time defaults to 1 second. </p>
    </dd>
</dl>
<dl>
  <dt id="dfn-createBiquadFilter">The <code>createBiquadFilter</code>
  method</dt>
    <dd><p>Creates a <a
      href="#BiquadFilterNode-section"><code>BiquadFilterNode</code></a>
      representing a second order filter which can be configured as one of
      several common filter types.</p>
    </dd>
</dl>
<dl>
  <dt id="dfn-createPanner">The <code>createPanner</code> method</dt>
    <dd><p>Creates an <a
      href="#AudioPannerNode-section"><code>AudioPannerNode</code></a>.</p>
    </dd>
</dl>
<dl>
  <dt id="dfn-createConvolver">The <code>createConvolver</code> method</dt>
    <dd><p>Creates a <a
      href="#ConvolverNode-section"><code>ConvolverNode</code></a>.</p>
    </dd>
</dl>
<dl>
  <dt id="dfn-createChannelSplitter">The <code>createChannelSplitter</code>
  method</dt>
    <dd><p>Creates an <a
      href="#AudioChannelSplitter-section"><code>AudioChannelSplitter</code></a>
      representing a channel splitter.  An exception will be thrown for invalid parameter values.</p>
      <p>The <dfn id="dfn-numberOfOutputs">numberOfOutputs</dfn> parameter
      determines the number of outputs.  Values of up to 32 must be supported.  If not specified, then 6 will be used. </p>
    </dd>
</dl>
<dl>
  <dt id="dfn-createChannelMerger">The <code>createChannelMerger</code>
  method</dt>
    <dd><p>Creates an <a
      href="#AudioChannelMerger-section"><code>AudioChannelMerger</code></a>
      representing a channel merger.  An exception will be thrown for invalid parameter values.</p>
      <p>The <dfn id="dfn-numberOfInputs">numberOfInputs</dfn> parameter
      determines the number of inputs.  Values of up to 32 must be supported.  If not specified, then 6 will be used. </p>
    </dd>
</dl>
<dl>
  <dt id="dfn-createDynamicsCompressor">The
  <code>createDynamicsCompressor</code> method</dt>
    <dd><p>Creates a <a
      href="#DynamicsCompressorNode-section"><code>DynamicsCompressorNode</code></a>.</p>
    </dd>
</dl>
<dl>
  <dt id="dfn-createOscillator">The
  <code>createOscillator</code> method</dt>
    <dd><p>Creates an <a
      href="#Oscillator-section"><code>Oscillator</code></a>.</p>
    </dd>
</dl>
<dl>
  <dt id="dfn-createWaveTable">The
  <code>createWaveTable</code> method</dt>
    <dd><p>Creates a <a
      href="#WaveTable-section"><code>WaveTable</code></a> representing a waveform containing arbitrary harmonic content.
      The <code>real</code> and <code>imag</code> parameters must be of type <code>Float32Array</code> of equal
      lengths greater than zero and less than or equal to 4096 or an exception will be thrown.
      These parameters specify the Fourier coefficients of a
      <a href="http://en.wikipedia.org/wiki/Fourier_series">Fourier series</a> representing the partials of a periodic waveform.
      The created WaveTable will be used with an <a href="#Oscillator-section"><code>Oscillator</code></a>
      and will represent a <em>normalized</em> time-domain waveform having maximum absolute peak value of 1.
      Another way of saying this is that the generated waveform of an <a href="#Oscillator-section"><code>Oscillator</code></a>
      will have maximum peak value at 0dBFS. Conveniently, this corresponds to the full-range of the signal values used by the Web Audio API.
      Because the WaveTable will be normalized on creation, the <code>real</code> and <code>imag</code> parameters
      represent <em>relative</em> values.
      </p>
      <p>The <dfn id="dfn-real">real</dfn> parameter represents an array of <code>cosine</code> terms (traditionally the A terms).
      In audio terminology, the first element (index 0) is the DC-offset of the periodic waveform and is usually set to zero.
      The second element (index 1) represents the fundamental frequency.  The third element represents the first overtone, and so on.</p>
      <p>The <dfn id="dfn-imag">imag</dfn> parameter represents an array of <code>sine</code> terms (traditionally the B terms).
      The first element (index 0) should be set to zero (and will be ignored) since this term does not exist in the Fourier series.
      The second element (index 1) represents the fundamental frequency.  The third element represents the first overtone, and so on.</p>
    </dd>
</dl>
</div>
</div>

<h3 id="lifetime-AudioContext">4.1.3. Lifetime</h3>
<p>
Once created, an <code>AudioContext</code> will not be garbage collected.  It will live until the document goes away.
</p>



<div id="AudioNode-section-section" class="section">
<h2 id="AudioNode-section">4.2. The AudioNode Interface</h2>

<p>AudioNodes are the building blocks of an <a
href="#AudioContext-section"><code>AudioContext</code></a>. This interface
represents audio sources, the audio destination, and intermediate processing
modules. These modules can be connected together to form <a
href="#ModularRouting-section">processing graphs</a> for rendering audio to the
audio hardware. Each node can have inputs and/or outputs. An <a
href="#AudioSourceNode-section"><code>AudioSourceNode</code></a> has no inputs
and a single output. An <a
href="#AudioDestinationNode-section"><code>AudioDestinationNode</code></a> has
one input and no outputs and represents the final destination to the audio
hardware. Most processing nodes such as filters will have one input and one
output. </p>

<p>
For performance reasons, practical implementations will need to use block processing, with each <code>AudioNode</code> processing a
fixed number of sample-frames of size <em>block-size</em>.  In order to get uniform behavior across implementations, we will define this
value explicitly.  <em>block-size</em> is defined to be 128 sample-frames which corresponds to roughly 3ms at a sample-rate of 44.1KHz.
</p>

<div class="block">

<div class="blockTitleDiv">
<span class="blockTitle">Web IDL</span></div>

<div class="blockContent">
<pre class="code"><code class="idl-code">

interface <dfn id="dfn-AudioNode">AudioNode</dfn> {

    void connect(AudioNode destination, optional unsigned long output = 0, optional unsigned long input = 0);

    void connect(AudioParam destination, optional unsigned long output = 0);

    void disconnect(optional unsigned long output = 0);

    readonly attribute AudioContext context;
    readonly attribute unsigned long numberOfInputs;
    readonly attribute unsigned long numberOfOutputs;

};
</code></pre>
</div>
</div>

<div id="attributes-AudioNode-section" class="section">
<h3 id="attributes-AudioNode">4.2.1. Attributes</h3>
<dl>
  <dt id="dfn-context"><code>context</code></dt>
    <dd><p>The AudioContext which owns this AudioNode.</p>
    </dd>
</dl>
<dl>
  <dt id="dfn-numberOfInputs_2"><code>numberOfInputs</code></dt>
    <dd><p>The number of inputs feeding into the AudioNode. This will be 0 for
      an AudioSourceNode.</p>
    </dd>
</dl>
<dl>
  <dt id="dfn-numberOfOutputs_2"><code>numberOfOutputs</code></dt>
    <dd><p>The number of outputs coming out of the AudioNode. This will be 0
      for an AudioDestinationNode.</p>
    </dd>
</dl>
</div>

<div id="methodsandparams-AudioNode-section" class="section">
<h3 id="methodsandparams-AudioNode">4.2.2. Methods and Parameters</h3>
<dl>
  <dt id="dfn-connect-AudioNode">The <code>connect</code> to AudioNode method</dt>
    <dd><p>Connects the AudioNode to another AudioNode.</p>
      <p>The <dfn id="dfn-destination_2">destination</dfn> parameter is the
      AudioNode to connect to.</p>
      <p>The <dfn id="dfn-output_2">output</dfn> parameter is an index
      describing which output of the AudioNode from which to connect. An
      out-of-bound value throws an exception.</p>
      <p>The <dfn id="dfn-input_2">input</dfn> parameter is an index describing
      which input of the destination AudioNode to connect to. An out-of-bound
      value throws an exception. </p>
      <p>It is possible to connect an AudioNode output to more than one input
      with multiple calls to connect(). Thus, "fanout" is supported. </p>
      <p>
      It is possible to connect an AudioNode to another AudioNode which creates a <em>cycle</em>.
      In other words, an AudioNode may connect to another AudioNode, which in turn connects back
      to the first AudioNode.  This is allowed only if there is at least one
      <a class="dfnref" href="#DelayNode-section">DelayNode</a> in the <em>cycle</em> or an exception will
      be thrown.
      </p>
    </dd>
</dl>
<dl>
  <dt id="dfn-connect-AudioParam">The <code>connect</code> to AudioParam method</dt>
    <dd><p>Connects the AudioNode to an AudioParam, controlling the parameter
      value with an audio-rate signal.
      </p>

      <p>It is possible to connect an AudioNode output to more than one AudioParam
      with multiple calls to connect(). Thus, "fanout" is supported. </p>
      <p>It is possible to connect more than one AudioNode output to a single AudioParam
      with multiple calls to connect().  Thus, "fanin" is supported. </p>
      <p>An AudioParam will take the rendered audio data from any AudioNode output connected to it and <a href="#down-mix">convert it to mono</a> by down-mixing if it is not
      already mono, then mix it together with other such outputs and finally will mix with the <em>intrinsic</em>
      parameter value (the value the AudioParam would normally have without any audio connections), including any timeline changes
      scheduled for the parameter. </p>

      <p>The <dfn id="dfn-destination_3">destination</dfn> parameter is the
      AudioParam to connect to.</p>
      <p>The <dfn id="dfn-output_3-destination">output</dfn> parameter is an index
      describing which output of the AudioNode from which to connect. An
      out-of-bound value throws an exception.</p>      
    </dd>
</dl>
<dl>
  <dt id="dfn-disconnect">The <code>disconnect</code> method</dt>
    <dd><p>Disconnects an AudioNode's output.</p>
      <p>The <dfn id="dfn-output_3-disconnect">output</dfn> parameter is an index
      describing which output of the AudioNode to disconnect.  An out-of-bound
      value throws an exception.</p>
    </dd>
</dl>
</div>
</div>

<h3 id="lifetime-AudioNode">4.2.3. Lifetime</h3>
<p>
An <code>AudioNode</code> will live as long as there are any references to it.  There are several types of references:
</p>

<ol>
<li>A <em>normal</em> JavaScript reference obeying normal garbage collection rules. </li>
<li>A <em>playing</em> reference for an <code>AudioSourceNode</code>.  Please see details for each specific
<code>AudioSourceNode</code> sub-type.  For example, both <code>AudioBufferSourceNodes</code> and <code>OscillatorNodes</code> maintain a <em>playing</em>
reference to themselves while they are in the SCHEDULED_STATE or PLAYING_STATE.</li>
<li>A <em>connection</em> reference which occurs if another <code>AudioNode</code> is connected to it.   </li>
<li>A <em>tail-time</em> reference which an <code>AudioNode</code> maintains on itself as long as it has
any internal processing state which has not yet been emitted.  For example, a <code>ConvolverNode</code> has
a tail which continues to play even after receiving silent input (think about clapping your hands in a large concert
  hall and continuing to hear the sound reverberate throughout the hall).  Some <code>AudioNodes</code> have this
  property.  Please see details for specific nodes.</li>
</ol>

<p>
Any <code>AudioNodes</code> which are connected in a cycle <em>and</em> are directly or indirectly connected to the
<code>AudioDestinationNode</code> of the <code>AudioContext</code> will stay alive as long as the <code>AudioContext</code> is alive.
</p>

<p>
When an <code>AudioNode</code> has no references it will be deleted.  But before it is deleted, the implementation must disconnect the node
from any other <code>AudioNodes</code> which it is connected to.  In this way it releases all connection references (3) it has to other nodes.
</p>

<p>
Regardless of any of the above references, an <code>AudioNode</code> will be deleted when its <code>AudioContext</code> is deleted.
</p>

<div id="AudioSourceNode-section" class="section">
<h2 id="AudioSourceNode">4.3. The AudioSourceNode Interface</h2>

<p>This is an abstract interface representing an audio source, an <a
href="#AudioNode-section"><code>AudioNode</code></a> which has no inputs and a
single output: </p>
<pre>      numberOfInputs  : 0
      numberOfOutputs : 1
      </pre>

<p>Subclasses of AudioSourceNode will implement specific types of audio
sources. </p>

<div class="block">

<div class="blockTitleDiv">
<span class="blockTitle">Web IDL</span></div>

<div class="blockContent">
<pre class="code"><code class="idl-code">

interface <dfn id="dfn-AudioSourceNode">AudioSourceNode</dfn> : AudioNode {

};
</code></pre>
</div>
</div>
</div>

<div id="AudioDestinationNode-section" class="section">
<h2 id="AudioDestinationNode">4.4. The AudioDestinationNode Interface</h2>

<p>This is an <a href="#AudioNode-section"><code>AudioNode</code></a>
representing the final audio destination and is what the user will ultimately
hear. It can be considered as an audio output device which is connected to
speakers. All rendered audio to be heard will be routed to this node, a
"terminal" node in the AudioContext's routing graph. There is only a single
AudioDestinationNode per AudioContext, provided through the
<code>destination</code> attribute of <a
href="#AudioContext-section"><code>AudioContext</code></a>. </p>
<pre>      numberOfInputs  : 1
      numberOfOutputs : 0
      </pre>

<div class="block">

<div class="blockTitleDiv">
<span class="blockTitle">Web IDL</span></div>

<div class="blockContent">
<pre class="code"><code class="idl-code">

interface <dfn id="dfn-AudioDestinationNode">AudioDestinationNode</dfn> : AudioNode {

    readonly attribute unsigned long maxNumberOfChannels;
    attribute unsigned long numberOfChannels;

};
</code></pre>
</div>
</div>

<div id="attributes-AudioDestinationNode-section" class="section">
<h3 id="attributes-AudioDestinationNode">4.4.1. Attributes</h3>
<dl>
  <dt id="dfn-maxNumberOfChannels"><code>maxNumberOfChannels</code></dt>
    <dd><p>The maximum number of channels that the <code>numberOfChannels</code> attribute can be set to.
    An <code>AudioDestinationNode</code> representing the audio hardware end-point (the normal case) can potentially output more than
    2 channels of audio if the audio hardware is multi-channel.  <code>maxNumberOfChannels</code> is the maximum number of channels that
    this hardware is capable of supporting.  If this value is 0, then this indicates that <code>maxNumberOfChannels</code> may not be
    changed.  This will be the case for an <code>AudioDestinationNode</code> in an <code>OfflineAudioContext</code>.</p>
    </dd>
</dl>

<dl>
  <dt id="dfn-numberOfChannels_2"><code>numberOfChannels</code></dt>
    <dd><p>The number of channels of the destination's input.  This value will default to 2, and may be set to any non-zero value less than or equal
    to <code>maxNumberOfChannels</code>.  An exception will be thrown if this value is not within the valid range.  Giving a concrete example, if
    the audio hardware supports 8-channel output, then we may set <code>numberOfChannels</code> to 8, and render 8-channels of output.  </p>
    </dd>
</dl>
</div>
</div>

<div id="AudioParam-section" class="section">
<h2 id="AudioParam">4.5. The AudioParam Interface</h2>

<p>AudioParam controls an individual aspect of an <a
href="#AudioNode-section"><code>AudioNode</code></a>'s functioning, such as
volume. The parameter can be set immediately to a particular value using the
"value" attribute. Or, value changes can be scheduled to happen at
very precise times (in the coordinate system of AudioContext.currentTime), for envelopes, volume fades, LFOs, filter sweeps, grain
windows, etc. In this way, arbitrary timeline-based automation curves can be
set on any AudioParam.  Additionally, audio signals from the outputs of <code>AudioNodes</code> can be connected
to an <code>AudioParam</code>, summing with the <em>intrinsic</em> parameter value.
</p>

<p>
The <em>final</em> parameter value used to control the audio DSP is calculated as follows:
</p>

<ol>
<li>An <em>intrinsic</em> parameter value will be calculated at each time, which is either the value set directly to the .value attribute,
or, if there are any scheduled parameter changes (automation events), the value as calculated from these events.  If the .value attribute
is directly set during a time when there are any automation events, then it will be ignored.  When read, the .value attribute
always returns the <em>intrinsic</em> value for the current time.  If automation events are removed from a given time range, then the
<em>intrinsic</em> value will remain unchanged and stay at its previous value until either the .value attribute is directly set, or automation events are added
for the time range.
</li>

<li>
An AudioParam will take the rendered audio data from any AudioNode output connected to it and <a href="#down-mix">convert it to mono</a> by down-mixing if it is not
already mono, then mix it together with other such outputs.
</li>

<li>
The <em>final</em> parameter value is the sum of the <em>intrinsic</em> value and the value calculated from (2).
</li>

</ol>

<p>
Some synthesis and processing <code>AudioNodes</code> have <code>AudioParams</code> as attributes whose values must
 be taken into account on a per-audio-sample basis.
For other <code>AudioParams</code>, sample-accuracy is not important and the value changes can be sampled more coarsely.
Each individual <code>AudioParam</code> will specify that it is either an <em>a-rate</em> parameter
which means that its values must be taken into account on a per-audio-sample basis, or it is a <em>k-rate</em> parameter whose value
changes must be taken into account at least at a 3ms resolution, but can be more precise than this.  
</p>

<p>
Because practical implementations will use <em>block</em> processing, and will process a fixed number of sample-frames at a time
(<em>block-size</em> sample-frames).  For each block, the value of a <em>k-rate</em>
parameter will be sampled at the time of the very first sample-frame, and that value will be used for the entire block.
</p>

<div class="block">

<div class="blockTitleDiv">
<span class="blockTitle">Web IDL</span></div>

<div class="blockContent">
<pre class="code"><code class="idl-code">

interface <dfn id="dfn-AudioParam">AudioParam</dfn> {

    attribute float value;
    readonly attribute float minValue;
    readonly attribute float maxValue;
    readonly attribute float defaultValue;

    <span class="comment">// Parameter automation. </span>
    void setValueAtTime(float value, float time);
    void linearRampToValueAtTime(float value, float time);
    void exponentialRampToValueAtTime(float value, float time);

    <span class="comment">// Exponentially approach the target value with a rate having the given time constant. </span>
    void setTargetValueAtTime(float targetValue, float time, float timeConstant);

    <span class="comment">// Sets an array of arbitrary parameter values starting at time for the given duration. </span>
    <span class="comment">// The number of values will be scaled to fit into the desired duration. </span>
    void setValueCurveAtTime(Float32Array values, float time, float duration);

    <span class="comment">// Cancels all scheduled parameter changes with times greater than or equal to startTime. </span>
    void cancelScheduledValues(float startTime);

};
</code></pre>
</div>
</div>

<div id="attributes-AudioParam-section" class="section">
<h3 id="attributes-AudioParam">4.5.1. Attributes</h3>
<dl>
  <dt id="dfn-value"><code>value</code></dt>
    <dd><p>The parameter's floating-point value. If a value is set outside the
      allowable range described by <code>minValue</code> and
      <code>maxValue</code> no exception is thrown, because these limits are just nominal and may be
      exceeded. </p>
    </dd>
</dl>
<dl>
  <dt id="dfn-minValue"><code>minValue</code></dt>
    <dd><p>Nominal minimum value. The <code>value</code> attribute may be set
      lower than this value.</p>
    </dd>
</dl>
<dl>
  <dt id="dfn-maxValue"><code>maxValue</code></dt>
    <dd><p>Nominal maximum value. The <code>value</code> attribute may be set higher than this value. </p>
    </dd>
</dl>
<dl>
  <dt id="dfn-defaultValue"><code>defaultValue</code></dt>
    <dd><p>Initial value for the value attribute</p>
    </dd>
</dl>
</div>

<div id="methodsandparams-AudioParam-section" class="section">
<h3 id="methodsandparams-AudioParam">4.5.2. Methods and Parameters</h3>

<p>
An <code>AudioParam</code> maintains a time-ordered event list which is initially empty.  The times are in
the time coordinate system of AudioContext.currentTime.  The events define a mapping from time to value.  The following methods
can change the event list by adding a new event into the list of a type specific to the method.  Each event
has a time associated with it, and the events will always be kept in time-order in the list.  These
methods will be called <em>automation</em> methods:</p>

<ul>
<li>setValueAtTime() - <em>SetValue</em></li>
<li>linearRampToValueAtTime() - <em>LinearRampToValue</em></li>
<li>exponentialRampToValueAtTime() - <em>ExponentialRampToValue</em></li>
<li>setTargetValueAtTime() - <em>SetTargetValue</em></li>
<li>setValueCurveAtTime() - <em>SetValueCurve</em></li>
</ul>

<p>
The following rules will apply when calling these methods:
</p>
<ul>
<li>If one of these events is added at a time where there is already an event of the exact same type, then the new event will replace the old
one.</li>
<li>If one of these events is added at a time where there is already one or more events of a different type, then it will be
placed in the list after them, but before events whose times are after the event. </li>
<li>If setValueCurveAtTime() is called for time T and duration D and there are any events having a time greater than T, but less than
T + D, then an exception will be thrown.  In other words, it's not ok to schedule a value curve during a time period containing other events.</li>
<li>Similarly an exception will be thrown if any <em>automation</em> method is called at a time which is inside of the time interval
of a <em>SetValueCurve</em> event at time T and duration D.</li>
</ul>
<p>
</p>

<dl>
  <dt id="dfn-setValueAtTime">The <code>setValueAtTime</code> method</dt>
    <dd><p>Schedules a parameter value change at the given time.</p>
      <p>The <dfn id="dfn-value_2">value</dfn> parameter is the value the
      parameter will change to at the given time.</p>
      <p>The <dfn id="dfn-time_2">time</dfn> parameter is the time in the same time coordinate system as AudioContext.currentTime.</p>
      <p>
      If there are no more events after this <em>SetValue</em> event, then for t >= time,  v(t) = value.  In other words, the value will remain constant.
      </p>
      <p>
      If the next event (having time T1) after this <em>SetValue</em> event is not of type <em>LinearRampToValue</em> or <em>ExponentialRampToValue</em>,
      then, for t: time &lt;= t &lt; T1,  v(t) = value.
      In other words, the value will remain constant during this time interval, allowing the creation of "step" functions.
      </p>
      <p>
      If the next event after this <em>SetValue</em> event is of type <em>LinearRampToValue</em> or <em>ExponentialRampToValue</em> then please
      see details below.
      </p>
    </dd>
</dl>
<dl>
  <dt id="dfn-linearRampToValueAtTime">The <code>linearRampToValueAtTime</code>
  method</dt>
    <dd><p>Schedules a linear continuous change in parameter value from the
      previous scheduled parameter value to the given value.</p>
      <p>The <dfn id="dfn-value_3">value</dfn> parameter is the value the
      parameter will linearly ramp to at the given time.</p>
      <p>The <dfn id="dfn-time_3">time</dfn> parameter is the time in the same time coordinate system as AudioContext.currentTime.</p>

      <p>
      The value during the time interval T0 &lt;= t &lt; T1 (where T0 is the time of the previous event and T1 is the time parameter passed into this method)
      will be calculated as:
      </p>
      <pre>
      v(t) = V0 + (V1 - V0) * ((t - T0) / (T1 - T0))
      </pre>
      <p>
      Where V0 is the value at the time T0 and V1 is the value parameter passed into this method.
      </p>
      <p>
      If there are no more events after this LinearRampToValue event then for t >= T1, v(t) = V1
      </p>

    </dd>
</dl>
<dl>
  <dt id="dfn-exponentialRampToValueAtTime">The
  <code>exponentialRampToValueAtTime</code> method</dt>
    <dd><p>Schedules an exponential continuous change in parameter value from
      the previous scheduled parameter value to the given value. Parameters
      representing filter frequencies and playback rate are best changed
      exponentially because of the way humans perceive sound. </p>
      <p>The <dfn id="dfn-value_4">value</dfn> parameter is the value the
      parameter will exponentially ramp to at the given time.  An exception will be thrown if this value is less than
      or equal to 0, or if the value at the time of the previous event is less than or equal to 0.</p>
      <p>The <dfn id="dfn-time_4">time</dfn> parameter is the time in the same time coordinate system as AudioContext.currentTime.</p>
      <p>
      The value during the time interval T0 &lt;= t &lt; T1 (where T0 is the time of the previous event and T1 is the time parameter passed into this method)
      will be calculated as:
      </p>
      <pre>
      v(t) = V0 * (V1 / V0) ^ ((t - T0) / (T1 - T0))
      </pre>
      <p>
      Where V0 is the value at the time T0 and V1 is the value parameter passed into this method.
      </p>
      <p>
      If there are no more events after this ExponentialRampToValue event then for t >= T1, v(t) = V1
      </p>
    </dd>
</dl>
<dl>
  <dt id="dfn-setTargetValueAtTime">The <code>setTargetValueAtTime</code>
  method</dt>
    <dd><p>Start exponentially approaching the target value at the given time
      with a rate having the given time constant. Among other uses, this is
      useful for implementing the "decay" and "release" portions of an ADSR
      envelope. Please note that the parameter value does not immediately
      change to the target value at the given time, but instead gradually
      changes to the target value.</p>
      <p>The <dfn id="dfn-targetValue">targetValue</dfn> parameter is the value
      the parameter will <em>start</em> changing to at the given time.</p>
      <p>The <dfn id="dfn-time">time</dfn> parameter is the time in the same time coordinate system as AudioContext.currentTime.</p>
      <p>The <dfn id="dfn-timeConstant">timeConstant</dfn> parameter is the
      time-constant value of first-order filter (exponential) approach to the
      target value. The larger this value is, the slower the transition will
      be.</p>
      <p>
      More precisely, <em>timeConstant</em> is the time it takes a first-order linear continuous time-invariant system
      to reach the value 1 - 1/e (around 63.2%) given a step input response (transition from 0 to 1 value).
      </p>
      <p>
      During the time interval: <em>T0</em> &lt;= t &lt; <em>T1</em>, where T0 is the <em>time</em> parameter and T1 represents the time of the event following this
      event (or <em>infinity</em> if there are no following events):
      </p>
      <pre>
      v(t) = V1 + (V0 - V1) * exp(-(t - T0) / <em>timeConstant</em>)
      </pre>
      <p>
      Where V0 is the initial value (the .value attribute) at T0 (the <em>time</em> parameter) and V1 is equal to the <em>targetValue</em>
      parameter.
      </p>
    </dd>
</dl>
<dl>
  <dt id="dfn-setValueCurveAtTime">The <code>setValueCurveAtTime</code>
  method</dt>
    <dd><p>Sets an array of arbitrary parameter values starting at the given
      time for the given duration. The number of values will be scaled to fit
      into the desired duration. </p>
      <p>The <dfn id="dfn-values">values</dfn> parameter is a Float32Array
      representing a parameter value curve. These values will apply starting at
      the given time and lasting for the given duration. </p>
      <p>The <dfn id="dfn-time_5">time</dfn> parameter is the time in the same time coordinate system as AudioContext.currentTime.</p>
      <p>The <dfn id="dfn-duration_5">duration</dfn> parameter is the
      amount of time in seconds (after the <em>time</em> parameter) where values will be calculated according to the <em>values</em> parameter..</p>
      <p>
      During the time interval: <em>time</em> &lt;= t &lt; <em>time</em> + <em>duration</em>, values will be calculated:
      </p>
      <pre>
      v(t) = values[N * (t - time) / duration], where <em>N</em> is the length of the <em>values</em> array.
      </pre>
    </dd>
</dl>
<dl>
  <dt id="dfn-cancelScheduledValues">The <code>cancelScheduledValues</code>
  method</dt>
    <dd><p>Cancels all scheduled parameter changes with times greater than or
      equal to startTime.</p>
      <p>The <dfn id="dfn-startTime">startTime</dfn> parameter is the starting
      time at and after which any previously scheduled parameter changes will
      be cancelled.  It is a time in the same time coordinate system as AudioContext.currentTime.</p>
    </dd>
</dl>
</div>
</div>


<div id="example1-AudioParam-section" class="section">
<h3 id="example1-AudioParam">4.5.3. AudioParam Automation Example</h3>



<div class="example">

<div class="exampleHeader">
Example</div>
<img alt="AudioParam automation" src="images/audioparam-automation1.png" /> 

<div class="block">

<div class="blockTitleDiv">
<span class="blockTitle">ECMAScript</span></div>

<div class="blockContent">
<pre class="code"><code class="es-code"> 
var t0 = 0;
var t1 = 0.1;
var t2 = 0.2;
var t3 = 0.3;
var t4 = 0.4;
var t5 = 0.6;
var t6 = 0.7;
var t7 = 1.0;

var curveLength = 44100;
var curve = new Float32Array(curveLength);
for (var i = 0; i &lt; curveLength; ++i)
    curve[i] = Math.sin(Math.PI * i / curveLength);

param.setValueAtTime(0.2, t0);
param.setValueAtTime(0.3, t1);
param.setValueAtTime(0.4, t2);
param.linearRampToValueAtTime(1, t3);
param.linearRampToValueAtTime(0.15, t4);
param.exponentialRampToValueAtTime(0.75, t5);
param.exponentialRampToValueAtTime(0.05, t6);
param.setValueCurveAtTime(curve, t6, t7 - t6);
</code></pre>
</div>
</div>
</div>
</div>



<div id="AudioGain-section-section" class="section">
<h3 id="AudioGain-section">4.6. AudioGain</h3>

<p>This interface is a particular type of <code>AudioParam</code> which
specifically controls the gain (volume) of some aspect of the audio processing.
The unit type is "linear gain". The nominal <code>minValue</code> is 0, but may be
set negative for phase inversion.  The nominal <code>maxValue</code> is 1, but higher values are allowed (no
exception thrown). </p>

<div class="block">

<div class="blockTitleDiv">
<span class="blockTitle">Web IDL</span></div>

<div class="blockContent">
<pre class="code"><code class="idl-code">

interface <dfn id="dfn-AudioGain">AudioGain</dfn> : AudioParam {

};
</code></pre>
</div>
</div>
</div>

<div id="AudioGainNode-section" class="section">
<h2 id="AudioGainNode">4.7. The AudioGainNode Interface</h2>

<p>Changing the gain of an audio signal is a fundamental operation in audio
applications.  The <code>AudioGainNode</code> is one of the building blocks for creating <a
href="#MixerGainStructure-section">mixers</a>.
This interface is an AudioNode with a single input and single
output: </p>
<pre>    numberOfInputs  : 1
    numberOfOutputs : 1
    </pre>

<p>which multiplies the input audio signal by the (possibly time-varying) <code>gain</code> attribute, copying the result to the output.
 By default, it will take the input and pass it through to the output unchanged, which represents a constant gain change
 of 1. 
</p>

<p>
As with other <code>AudioParams</code>, the <code>gain</code> parameter represents a mapping from time
(in the coordinate system of AudioContext.currentTime) to floating-point value.

Every PCM audio sample in the input is multiplied by the <code>gain</code> parameter's value for the specific time
corresponding to that audio sample.  This multiplied value represents the PCM audio sample for the output.
</p>

<p>
The number of channels of the output will always equal the number of channels of the input, with each channel
of the input being multiplied by the <code>gain</code> values and being copied into the corresponding channel
of the output.
</p>

<p>
 The implementation must make
gain changes to the audio stream smoothly, without introducing noticeable
clicks or glitches. This process is called "de-zippering". </p>

<div class="block">

<div class="blockTitleDiv">
<span class="blockTitle">Web IDL</span></div>

<div class="blockContent">
<pre class="code"><code class="idl-code">

interface <dfn id="dfn-AudioGainNode">AudioGainNode</dfn> : AudioNode {

    AudioGain gain;

};
</code></pre>
</div>
</div>

<div id="attributes-AudioGainNode-section" class="section">
<h3 id="attributes-AudioGainNode">4.7.1. Attributes</h3>
<dl>
  <dt id="dfn-gain"><code>gain</code></dt>
    <dd><p>An AudioGain object representing the amount of gain to apply. The
      default value (<code>gain.value</code>) is 1 (no gain change). See <a
      href="#AudioGain-section"><code>AudioGain</code></a> for more
      information.  This parameter is <em>a-rate</em> </p>
    </dd>
</dl>
</div>
</div>

<div id="DelayNode-section" class="section">
<h2 id="DelayNode">4.8. The DelayNode Interface</h2>

<p>A delay-line is a fundamental building block in audio applications. This
interface is an AudioNode with a single input and single output: </p>
<pre>    numberOfInputs  : 1
    numberOfOutputs : 1
    </pre>

<p>which delays the incoming audio signal by a certain amount. The default
amount is 0 seconds (no delay). When the delay time is changed, the
implementation must make the transition smoothly, without introducing
noticeable clicks or glitches to the audio stream. </p>

<div class="block">

<div class="blockTitleDiv">
<span class="blockTitle">Web IDL</span></div>

<div class="blockContent">
<pre class="code"><code class="idl-code">

interface <dfn id="dfn-DelayNode">DelayNode</dfn> : AudioNode {

    AudioParam delayTime;

};
</code></pre>
</div>
</div>

<div id="attributes-AudioGainNode-section_2" class="section">
<h3 id="attributes-AudioGainNode_2">4.8.1. Attributes</h3>
<dl>
  <dt id="dfn-delayTime_2"><code>delayTime</code></dt>
    <dd><p>An AudioParam object representing the amount of delay (in seconds)
      to apply. The default value (<code>delayTime.value</code>) is 0 (no
      delay). The minimum value is 0 and the maximum value is determined by the <em>maxDelayTime</em>
      argument to the <code>AudioContext</code> method <code>createDelayNode</code>.  This parameter is <em>k-rate</em></p>
    </dd>
</dl>
</div>
</div>

<div id="AudioBuffer-section" class="section">
<h2 id="AudioBuffer">4.9. The AudioBuffer Interface</h2>

<p>This interface represents a memory-resident audio asset (for one-shot sounds
and other short audio clips). Its format is non-interleaved IEEE 32-bit linear PCM with a
nominal range of -1 -&gt; +1. It can contain one or more channels. It is
analogous to a WebGL texture. Typically, it would be expected that the length
of the PCM data would be fairly short (usually somewhat less than a minute).
For longer sounds, such as music soundtracks, streaming should be used with the
<code>audio</code> element and <code>MediaElementAudioSourceNode</code>. </p>

<p>
An AudioBuffer may be used by one or more AudioContexts.
</p>

<div class="block">

<div class="blockTitleDiv">
<span class="blockTitle">Web IDL</span></div>

<div class="blockContent">
<pre class="code"><code class="idl-code">

interface <dfn id="dfn-AudioBuffer">AudioBuffer</dfn> {

    readonly attribute float sampleRate;
    readonly attribute long length;

    <span class="comment">// in seconds </span>
    readonly attribute float duration;

    readonly attribute long numberOfChannels;

    Float32Array getChannelData(unsigned long channel);

};
</code></pre>
</div>
</div>

<div id="attributes-AudioBuffer-section" class="section">
<h3 id="attributes-AudioBuffer">4.9.1. Attributes</h3>
<dl>
  <dt id="dfn-sampleRate_AudioBuffer"><code>sampleRate</code></dt>
    <dd><p>The sample-rate for the PCM audio data in samples per second.</p>
    </dd>
</dl>
<dl>
  <dt id="dfn-length_AudioBuffer"><code>length</code></dt>
    <dd><p>Length of the PCM audio data in sample-frames.</p>
    </dd>
</dl>
<dl>
  <dt id="dfn-duration_AudioBuffer"><code>duration</code></dt>
    <dd><p>Duration of the PCM audio data in seconds.</p>
    </dd>
</dl>
<dl>
  <dt id="dfn-numberOfChannels_AudioBuffer"><code>numberOfChannels</code></dt>
    <dd><p>The number of discrete audio channels.</p>
    </dd>
</dl>
</div>

<div id="methodsandparams-AudioBuffer-section" class="section">
<h3 id="methodsandparams-AudioBuffer">4.9.2. Methods and Parameters</h3>
<dl>
  <dt id="dfn-getChannelData">The <code>getChannelData</code> method</dt>
    <dd><p>Returns the <code>Float32Array</code> representing the PCM audio data for the specific channel.</p>
      <p>The <dfn id="dfn-channel">channel</dfn> parameter is an index
      representing the particular channel to get data for.  An index value of 0 represents
      the first channel.  This  index value MUST be less than <code>numberOfChannels</code>
      or an exception will be thrown.</p>
    </dd>
</dl>
</div>
</div>

<div id="AudioBufferSourceNode-section" class="section">
<h2 id="AudioBufferSourceNode">4.10. The AudioBufferSourceNode Interface</h2>

<p>This interface represents an audio source from an in-memory audio asset in
an <code>AudioBuffer</code>. It generally will be used for short audio assets
which require a high degree of scheduling flexibility (can playback in
rhythmically perfect ways). The playback state of an AudioBufferSourceNode goes
through distinct stages during its lifetime in this order: UNSCHEDULED_STATE,
SCHEDULED_STATE, PLAYING_STATE, FINISHED_STATE. The noteOn() method causes a transition from the
UNSCHEDULED_STATE to SCHEDULED_STATE. Depending on the time argument passed to
noteOn(), a transition is made from the SCHEDULED_STATE to PLAYING_STATE, at which
time sound is first generated. Following this, a transition from the PLAYING_STATE to
FINISHED_STATE happens when either the buffer's audio data has been completely
played (if the <code>loop</code> attribute is false), or when the noteOff()
method has been called and the specified time has been reached. Please see more
details in the noteOn() and noteOff() description. Once an
AudioBufferSourceNode has reached the FINISHED state it will no longer emit any
sound. Thus noteOn() and noteOff() may not be issued multiple times for a given
AudioBufferSourceNode. </p>
<pre>    numberOfInputs  : 0
    numberOfOutputs : 1
    </pre>

<div class="block">

<div class="blockTitleDiv">
<span class="blockTitle">Web IDL</span></div>

<div class="blockContent">
<pre class="code"><code class="idl-code">

interface <dfn id="dfn-AudioBufferSourceNode">AudioBufferSourceNode</dfn> : AudioSourceNode {

    const unsigned short UNSCHEDULED_STATE = 0;
    const unsigned short SCHEDULED_STATE = 1;
    const unsigned short PLAYING_STATE = 2;
    const unsigned short FINISHED_STATE = 3;

    readonly attribute unsigned short playbackState;

    <span class="comment">// Playback this in-memory audio asset  </span>
    <span class="comment">// Many sources can share the same buffer  </span>
    attribute AudioBuffer buffer;

    attribute AudioParam playbackRate;
    attribute boolean loop;

    void noteOn(double when);
    void noteGrainOn(double when, double grainOffset, double grainDuration);
    void noteOff(double when);

};
</code></pre>
</div>
</div>

<div id="attributes-AudioBufferSourceNode-section" class="section">
<h3 id="attributes-AudioBufferSourceNode">4.10.1. Attributes</h3>
<dl>
  <dt id="dfn-playbackState_AudioBufferSourceNode"><code>playbackState</code></dt>
    <dd><p>The playback state, initialized to UNSCHEDULED_STATE. </p>
    </dd>
</dl>
<dl>
  <dt id="dfn-buffer_AudioBufferSourceNode"><code>buffer</code></dt>
    <dd><p>Represents the audio asset to be played. </p>
    </dd>
</dl>
<dl>
  <dt id="dfn-playbackRate_AudioBufferSourceNode"><code>playbackRate</code></dt>
    <dd><p>The speed at which to render the audio stream. The default
      playbackRate.value is 1.  This parameter is <em>a-rate</em> </p>
    </dd>
</dl>
<dl>
  <dt id="dfn-loop_AudioBufferSourceNode"><code>loop</code></dt>
    <dd><p>Indicates if the audio data should play in a loop. </p>
    </dd>
</dl>
</div>
</div>

<div id="methodsandparams-AudioBufferSourceNode-section" class="section">
<h3 id="methodsandparams-AudioBufferSourceNode">4.10.2. Methods and
Parameters</h3>
<dl>
  <dt id="dfn-noteOn">The <code>noteOn</code> method</dt>
    <dd><p>Schedules a sound to playback at an exact time.</p>
      <p>The <dfn id="dfn-when">when</dfn> parameter describes at what time (in
      seconds) the sound should start playing. It is in the same
      time coordinate system as AudioContext.currentTime. If 0 is passed in for
      this value or if the value is less than <b>currentTime</b>, then the
      sound will start playing immediately.  Either <code>noteOn</code> or <code>noteGrainOn</code> (but not both) may only be called one time
      and must be called before <code>noteOff</code> is called or an exception will be thrown.</p>
    </dd>
</dl>
<dl>
  <dt id="dfn-noteGrainOn">The <code>noteGrainOn</code> method</dt>
    <dd><p>Schedules a portion of a sound to playback at an exact time.</p>
      <p>The <dfn id="dfn-when_AudioBufferSourceNode">when</dfn> parameter
      describes at what time (in seconds) the sound should start playing.
      It is in the same time coordinate system as AudioContext.currentTime.
      If 0 is passed in for this value or if the value is less than
      <b>currentTime</b>, then the sound will start playing immediately. </p>
      <p>The <dfn id="dfn-grainOffset">grainOffset</dfn> parameter describes
      the offset in the buffer (in seconds) for the portion to be played.</p>
      <p>The <dfn id="dfn-grainDuration">grainDuration</dfn> parameter
      describes the duration of the portion (in seconds) to be played.
      Either <code>noteOn</code> or <code>noteGrainOn</code> (but not both) may only be called one time
      and must be called before <code>noteOff</code> is called or an exception will be thrown. </p>
    </dd>
</dl>
<dl>
  <dt id="dfn-noteOff">The <code>noteOff</code> method</dt>
    <dd><p>Schedules a sound to stop playback at an exact time.</p>
      <p>The <dfn id="dfn-when_AudioBufferSourceNode_2">when</dfn> parameter
      describes at what time (in seconds) the sound should stop playing.
      It is in the same time coordinate system as AudioContext.currentTime.
      If 0 is passed in for this value or if the value is less than
      <b>currentTime</b>, then the sound will stop playing immediately.
      <code>noteOff</code> must only be called one time and only after a call to <code>noteOn</code> or <code>noteOff</code>,
      or an exception will be thrown.</p>
    </dd>
</dl>
</div>

<div id="MediaElementAudioSourceNode-section" class="section">
<h2 id="MediaElementAudioSourceNode">4.11. The MediaElementAudioSourceNode
Interface</h2>

<p>This interface represents an audio source from an <code>audio</code> or
<code>video</code> element. </p>
<pre>    numberOfInputs  : 0
    numberOfOutputs : 1
    </pre>

<div class="block">

<div class="blockTitleDiv">
<span class="blockTitle">Web IDL</span></div>

<div class="blockContent">
<pre class="code"><code class="idl-code">

interface <dfn id="dfn-MediaElementAudioSourceNode">MediaElementAudioSourceNode</dfn> : AudioSourceNode {

};
</code></pre>
</div>
</div>
</div>

<div id="JavaScriptAudioNode-section" class="section">
<h2 id="JavaScriptAudioNode">4.12. The JavaScriptAudioNode Interface</h2>

<p>This interface is an AudioNode which can generate, process, or analyse audio
directly using JavaScript. </p>
<pre>    numberOfInputs  : 1
    numberOfOutputs : 1
    </pre>

<p>The JavaScriptAudioNode is constructed with a <code>bufferSize</code> which
must be one of the following values: 256, 512, 1024, 2048, 4096, 8192, 16384.
This value controls how frequently the <code>onaudioprocess</code> event
handler is called and how many sample-frames need to be processed each call.
Lower numbers for <code>bufferSize</code> will result in a lower (better) <a
href="#Latency-section">latency</a>. Higher numbers will be necessary to avoid
audio breakup and <a href="#Glitching-section">glitches</a>. The value chosen
must carefully balance between latency and audio quality. </p>

<p><code>numberOfInputChannels</code> and <code>numberOfOutputChannels</code>
determine the number of input and output channels. It is invalid for both
<code>numberOfInputChannels</code> and <code>numberOfOutputChannels</code> to
be zero. </p>
<pre>    var node = context.createJavaScriptNode(bufferSize, numberOfInputChannels, numberOfOutputChannels);
    </pre>

<div class="block">

<div class="blockTitleDiv">
<span class="blockTitle">Web IDL</span></div>

<div class="blockContent">
<pre class="code"><code class="idl-code">

interface <dfn id="dfn-JavaScriptAudioNode">JavaScriptAudioNode</dfn> : AudioNode {

    attribute EventListener onaudioprocess;

    readonly attribute long bufferSize;

};
</code></pre>
</div>
</div>

<div id="attributes-JavaScriptAudioNode-section" class="section">
<h3 id="attributes-JavaScriptAudioNode">4.12.1. Attributes</h3>
<dl>
  <dt id="dfn-onaudioprocess"><code>onaudioprocess</code></dt>
    <dd><p>An event listener which is called periodically for audio processing.
      An event of type <a
      href="#AudioProcessingEvent-section"><code>AudioProcessingEvent</code></a>
      will be passed to the event handler. </p>
    </dd>
</dl>
<dl>
  <dt id="dfn-bufferSize_JavaScriptAudioNode"><code>bufferSize</code></dt>
    <dd><p>The size of the buffer (in sample-frames) which needs to be
      processed each time <code>onprocessaudio</code> is called. Legal values
      are (256, 512, 1024, 2048, 4096, 8192, 16384). </p>
    </dd>
</dl>
</div>
</div>

<div id="AudioProcessingEvent-section" class="section">
<h2 id="AudioProcessingEvent">4.13. The AudioProcessingEvent Interface</h2>

<p>This interface is a type of <code>Event</code> which is passed to the
<code>onaudioprocess</code> event handler used by <a
href="#JavaScriptAudioNode-section"><code>JavaScriptAudioNode</code></a>. </p>

<p>The event handler processes audio from the input (if any) by accessing the
audio data from the <code>inputBuffer</code> attribute. The audio data which is
the result of the processing (or the synthesized data if there are no inputs)
is then placed into the <code>outputBuffer</code>. </p>

<div class="block">

<div class="blockTitleDiv">
<span class="blockTitle">Web IDL</span></div>

<div class="blockContent">
<pre class="code"><code class="idl-code">

interface <dfn id="dfn-AudioProcessingEvent">AudioProcessingEvent</dfn> : Event {

    attribute JavaScriptAudioNode node;
    readonly attribute float playbackTime;
    readonly attribute AudioBuffer inputBuffer;
    readonly attribute AudioBuffer outputBuffer;

};
</code></pre>
</div>
</div>

<div id="attributes-AudioProcessingEvent-section" class="section">
<h3 id="attributes-AudioProcessingEvent">4.13.1. Attributes</h3>
<dl>
  <dt id="dfn-node"><code>node</code></dt>
    <dd><p>The <code>JavaScriptAudioNode</code> associated with this processing
      event. </p>
    </dd>
</dl>
<dl>
  <dt id="dfn-playbackTime"><code>playbackTime</code></dt>
    <dd><p>The time when the audio will be played in the same time coordinate system as AudioContext.currentTime.
      <code>playbackTime</code> allows for very tight synchronization between
      processing directly in JavaScript with the other events in the context's
      rendering graph. </p>
    </dd>
</dl>
<dl>
  <dt id="dfn-inputBuffer"><code>inputBuffer</code></dt>
    <dd><p>An AudioBuffer containing the input audio data.  It will have a number of channels equal to the <code>numberOfInputChannels</code> parameter
    of the createJavaScriptNode() method.  This AudioBuffer is only valid while in the scope of the <code>onaudioprocess</code>
    function.  Its values will be meaningless outside of this scope.</p>
    </dd>
</dl>
<dl>
  <dt id="dfn-outputBuffer"><code>outputBuffer</code></dt>
    <dd><p>An AudioBuffer where the output audio data should be written.  It will have a number of channels equal to the
    <code>numberOfOutputChannels</code> parameter of the createJavaScriptNode() method.
      Script code within the scope of the <code>onaudioprocess</code> function is expected to modify the
      <code>Float32Array</code> arrays representing channel data in this AudioBuffer.
      Any script modifications to this AudioBuffer outside of this scope will not produce any audible effects.</p>
    </dd>
</dl>
</div>
</div>

<div id="AudioPannerNode-section" class="section">
<h2 id="AudioPannerNode">4.14. The AudioPannerNode Interface</h2>

<p>This interface represents a processing node which <a
href="#Spatialization-section">positions / spatializes</a> an incoming audio
stream in three-dimensional space. The spatialization is in relation to the <a
href="#AudioContext-section"><code>AudioContext</code></a>'s <a
href="#AudioListener-section"><code>AudioListener</code></a>
(<code>listener</code> attribute). </p>

<pre>
    numberOfInputs  : 1
    numberOfOutputs : 1
</pre>

<p>
The audio stream from the input will be either mono or stereo, depending on the connection(s) to the input.
</p>

<p>
The output of this node is hard-coded to stereo (2 channels) and <em>currently</em> cannot be configured.
</p>


<div class="block">

<div class="blockTitleDiv">
<span class="blockTitle">Web IDL</span></div>

<div class="blockContent">
<pre class="code"><code class="idl-code">

interface <dfn id="dfn-AudioPannerNode">AudioPannerNode</dfn> : AudioNode {

    <span class="comment">// Panning model </span>
    const unsigned short EQUALPOWER = 0;
    const unsigned short HRTF = 1;
    const unsigned short SOUNDFIELD = 2;

    <span class="comment">// Distance model </span>
    const unsigned short LINEAR_DISTANCE = 0;
    const unsigned short INVERSE_DISTANCE = 1;
    const unsigned short EXPONENTIAL_DISTANCE = 2;

    <span class="comment">// Default for stereo is HRTF </span>
    attribute unsigned short panningModel;

    <span class="comment">// Uses a 3D cartesian coordinate system </span>
    void setPosition(float x, float y, float z);
    void setOrientation(float x, float y, float z);
    void setVelocity(float x, float y, float z);

    <span class="comment">// Distance model and attributes </span>
    attribute unsigned short distanceModel;
    attribute float refDistance;
    attribute float maxDistance;
    attribute float rolloffFactor;

    <span class="comment">// Directional sound cone </span>
    attribute float coneInnerAngle;
    attribute float coneOuterAngle;
    attribute float coneOuterGain;

    <span class="comment">// Dynamically calculated gain values </span>
    readonly attribute AudioGain coneGain;
    readonly attribute AudioGain distanceGain;

};
</code></pre>
</div>
</div>
</div>

<div id="AudioPannerNode-sub-section" class="section">
<h3 id="AudioPannerNode-sub">4.14.1. Constants</h3>
<dl>
  <dt id="dfn-EQUALPOWER"><code>EQUALPOWER</code></dt>
    <dd><p>A simple and efficient spatialization algorithm using equal-power
      panning. </p>
    </dd>
</dl>
<dl>
  <dt id="dfn-HRTF"><code>HRTF</code></dt>
    <dd><p>A higher quality spatialization algorithm using a convolution with
      measured impulse responses from human subjects. This panning method
      renders stereo output. </p>
    </dd>
</dl>
<dl>
  <dt id="dfn-SOUNDFIELD"><code>SOUNDFIELD</code></dt>
    <dd><p>An algorithm which spatializes multi-channel audio using sound field
      algorithms. </p>
    </dd>
</dl>
<dl>
  <dt id="dfn-LINEAR_DISTANCE"><code>LINEAR_DISTANCE</code></dt>
    <dd><p>A linear distance model which calculates <em>distanceGain</em> according to: </p>
    <pre>
1 - rolloffFactor * (distance - refDistance) / (maxDistance - refDistance)
    </pre>
    </dd>
</dl>
<dl>
  <dt id="dfn-INVERSE_DISTANCE"><code>INVERSE_DISTANCE</code></dt>
  <dd><p>An inverse distance model which calculates <em>distanceGain</em> according to: </p>
    <pre>
refDistance / (refDistance + rolloffFactor * (distance - refDistance))
    </pre>
    </dd>
</dl>
<dl>
  <dt id="dfn-EXPONENTIAL_DISTANCE"><code>EXPONENTIAL_DISTANCE</code></dt>
  <dd><p>An exponential distance model which calculates <em>distanceGain</em> according to: </p>
  <pre>
pow(distance / refDistance, -rolloffFactor)
  </pre>
    </dd>
</dl>
</div>

<div id="attributes-AudioPannerNode_attributes-section" class="section">
<h3 id="attributes-AudioPannerNode_attributes">4.14.2. Attributes</h3>
<dl>
  <dt id="dfn-listener_AudioPannerNode_attributes"><code>listener</code></dt>
    <dd><p>Represents the <b>listener</b> whose position and orientation is
      used together with the panner's position and orientation to determine how
      the audio will be spatialized. </p>
    </dd>
</dl>
<dl>
  <dt id="dfn-panningModel"><code>panningModel</code></dt>
    <dd><p>Determines which spatialization algorithm will be used to position
      the audio in 3D space. See the <b>constants</b> for the available
      choices. The default is <b>HRTF</b>. </p>
    </dd>
</dl>
<dl>
  <dt id="dfn-distanceModel"><code>distanceModel</code></dt>
    <dd><p>Determines which algorithm will be used to reduce the volume of an
      audio source as it moves away from the listener. 
      <!--span class="ednote">TODO: add constants </span --></p>
    </dd>
</dl>
<dl>
  <dt id="dfn-refDistance"><code>refDistance</code></dt>
    <dd><p>A reference distance for reducing volume as source move further from
      the listener. </p>
    </dd>
</dl>
<dl>
  <dt id="dfn-maxDistance"><code>maxDistance</code></dt>
    <dd><p>The maximum distance between source and listener, after which the
      volume will not be reduced any further. </p>
    </dd>
</dl>
<dl>
  <dt id="dfn-rolloffFactor"><code>rolloffFactor</code></dt>
    <dd><p>Describes how quickly the volume is reduced as source moves away
      from listener. </p>
    </dd>
</dl>
<dl>
  <dt id="dfn-coneInnerAngle"><code>coneInnerAngle</code></dt>
    <dd><p>A parameter for directional audio sources, this is an angle, inside
      of which there will be no volume reduction. </p>
    </dd>
</dl>
<dl>
  <dt id="dfn-coneOuterAngle"><code>coneOuterAngle</code></dt>
    <dd><p>A parameter for directional audio sources, this is an angle, outside
      of which the volume will be reduced to a constant value of
      <b>coneOuterGain</b>. </p>
    </dd>
</dl>
<dl>
  <dt id="dfn-coneOuterGain"><code>coneOuterGain</code></dt>
    <dd><p>A parameter for directional audio sources, this is the amount of
      volume reduction outside of the <b>coneOuterAngle</b>. </p>
    </dd>
</dl>
</div>

<h3 id="Methods_and_Parameters">4.14.3. Methods and Parameters</h3>
<dl>
  <dt id="dfn-setPosition">The <code>setPosition</code> method</dt>
    <dd><p>Sets the position of the audio source relative to the
      <b>listener</b> attribute. A 3D cartesian coordinate system is used.</p>
      <p>The <dfn id="dfn-x">x, y, z</dfn> parameters represent the coordinates
      in 3D space. </p>
    </dd>
</dl>
<dl>
  <dt id="dfn-setOrientation">The <code>setOrientation</code> method</dt>
    <dd><p>Describes which direction the audio source is pointing in the 3D
      cartesian coordinate space. Depending on how directional the sound is
      (controlled by the <b>cone</b> attributes), a sound pointing away from
      the listener can be very quiet or completely silent.</p>
      <p>The <dfn id="dfn-x_2">x, y, z</dfn> parameters represent a direction
      vector in 3D space. </p>
    </dd>
</dl>
<dl>
  <dt id="dfn-setVelocity">The <code>setVelocity</code> method</dt>
    <dd><p>Sets the velocity vector of the audio source. This vector controls
      both the direction of travel and the speed in 3D space. This velocity
      relative to the listener's velocity is used to determine how much doppler
      shift (pitch change) to apply.</p>
      <p>The <dfn id="dfn-x_3">x, y, z</dfn> parameters describe a direction
      vector indicating direction of travel and intensity. </p>
    </dd>
</dl>

<div id="AudioListener-section" class="section">
<h2 id="AudioListener">4.15. The AudioListener Interface</h2>

<p>This interface represents the position and orientation of the person
listening to the audio scene. All <a
href="#AudioPannerNode-section"><code>AudioPannerNode</code></a> objects
spatialize in relation to the AudioContext's <code>listener</code>. See <a
href="#Spatialization-section">this</a> section for more details about
spatialization. </p>

<div class="block">

<div class="blockTitleDiv">
<span class="blockTitle">Web IDL</span></div>

<div class="blockContent">
<pre class="code"><code class="idl-code">

interface <dfn id="dfn-AudioListener">AudioListener</dfn> {

    <span class="comment">// same as OpenAL (default 1) </span>
    attribute float dopplerFactor;

    <span class="comment">// in meters / second (default 343.3) </span>
    attribute float speedOfSound;

    <span class="comment">// Uses a 3D cartesian coordinate system </span>
    void setPosition(float x, float y, float z);
    void setOrientation(float x, float y, float z, float xUp, float yUp, float zUp);
    void setVelocity(float x, float y, float z);

};
</code></pre>
</div>
</div>
</div>

<div id="attributes-AudioListener-section" class="section">
<h3 id="attributes-AudioListener">4.15.1. Attributes</h3>
<dl>
  <dt id="dfn-dopplerFactor"><code>dopplerFactor</code></dt>
    <dd><p>A constant used to determine the amount of pitch shift to use when
      rendering a doppler effect. </p>
    </dd>
</dl>
<dl>
  <dt id="dfn-speedOfSound"><code>speedOfSound</code></dt>
    <dd><p>The speed of sound used for calculating doppler shift. The default
      value is 343.3 meters / second. </p>
    </dd>
</dl>
</div>

<h3 id="L15842">4.15.2. Methods and Parameters</h3>
<dl>
  <dt id="dfn-setPosition_2">The <code>setPosition</code> method</dt>
    <dd><p>Sets the position of the listener in a 3D cartesian coordinate
      space. <code>AudioPannerNode</code> objects use this position relative to
      individual audio sources for spatialization.</p>
      <p>The <dfn id="dfn-x_AudioListener">x, y, z</dfn> parameters represent
      the coordinates in 3D space. </p>
    </dd>
</dl>
<dl>
  <dt id="dfn-setOrientation_2">The <code>setOrientation</code> method</dt>
    <dd><p>Describes which direction the listener is pointing in the 3D
      cartesian coordinate space. Both a <b>front</b> vector and an <b>up</b>
      vector are provided.</p>
      <p>The <dfn id="dfn-x_setOrientation">x, y, z</dfn> parameters represent
      a <b>front</b> direction vector in 3D space. </p>
      <p>The <dfn id="dfn-x_setOrientation_2">xUp, yUp, zUp</dfn> parameters
      represent an <b>up</b> direction vector in 3D space. </p>
    </dd>
</dl>
<dl>
  <dt id="dfn-setVelocity_4">The <code>setVelocity</code> method</dt>
    <dd><p>Sets the velocity vector of the listener. This vector controls both
      the direction of travel and the speed in 3D space. This velocity relative
      an audio source's velocity is used to determine how much doppler shift
      (pitch change) to apply.</p>
      <p>The <dfn id="dfn-x_setVelocity_5">x, y, z</dfn> parameters describe a
      direction vector indicating direction of travel and intensity. </p>
    </dd>
</dl>

<div id="ConvolverNode-section" class="section">
<h2 id="ConvolverNode">4.16. The ConvolverNode Interface</h2>

<p>This interface represents a processing node which applies a <a
href="#Convolution-section">linear convolution effect</a> given an impulse
response.  Normative requirements for multi-channel convolution matrixing are described
<a href="#Convolution-reverb-effect">here</a>. </p>
<pre>    numberOfInputs  : 1
    numberOfOutputs : 1
    </pre>

<div class="block">

<div class="blockTitleDiv">
<span class="blockTitle">Web IDL</span></div>

<div class="blockContent">
<pre class="code"><code class="idl-code">

interface <dfn id="dfn-ConvolverNode">ConvolverNode</dfn> : AudioNode {

    attribute AudioBuffer buffer;
    attribute boolean normalize;

};
</code></pre>
</div>
</div>
</div>

<div id="attributes-ConvolverNode-section" class="section">
<h3 id="attributes-ConvolverNode">4.16.1. Attributes</h3>
<dl>
  <dt id="dfn-buffer_ConvolverNode"><code>buffer</code></dt>
    <dd><p>A mono, stereo, or 4-channel <code>AudioBuffer</code> containing the (possibly multi-channel) impulse response
      used by the ConvolverNode.  At the time when this attribute is set, the <em>buffer</em> and the state of the <em>normalize</em>
      attribute will be used to configure the ConvolverNode with this impulse response having the given normalization.</p>
    </dd>
</dl>
<dl>
  <dt id="dfn-normalize"><code>normalize</code></dt>
    <dd><p>Controls whether the impulse response from the buffer will be scaled
      by an equal-power normalization when the <code>buffer</code> atttribute
      is set. Its default value is <code>true</code> in order to achieve a more
      uniform output level from the convolver when loaded with diverse impulse
      responses. If <code>normalize</code> is set to <code>false</code>, then
      the convolution will be rendered with no pre-processing/scaling of the
      impulse response.  Changes to this value do not take effect until the next time
      the <em>buffer</em> attribute is set. </p>
      
    </dd>
</dl>

      <p>
      If the <em>normalize</em> attribute is false when the <em>buffer</em> attribute is set then the
      ConvolverNode will perform a linear convolution given the exact impulse response contained within the <em>buffer</em>.
      </p>
      <p>
      Otherwise, if the <em>normalize</em> attribute is true when the <em>buffer</em> attribute is set then the
      ConvolverNode will first perform a scaled RMS-power analysis of the audio data contained within <em>buffer</em> to calculate a
      <em>normalizationScale</em> given this algorithm:
      </p>


      <div class="block">

      <div class="blockTitleDiv">

      <div class="blockContent">
      <pre class="code"><code class="idl-code"> 

float calculateNormalizationScale(buffer)
{
    const float GainCalibration = 0.00125;
    const float GainCalibrationSampleRate = 44100;
    const float MinPower = 0.000125;
  
    // Normalize by RMS power.
    size_t numberOfChannels = buffer->numberOfChannels();
    size_t length = buffer->length();

    float power = 0;

    for (size_t i = 0; i &lt; numberOfChannels; ++i) {
        float* sourceP = buffer->channel(i)->data();
        float channelPower = 0;

        int n = length;
        while (n--) {
            float sample = *sourceP++;
            channelPower += sample * sample;
        }

        power += channelPower;
    }

    power = sqrt(power / (numberOfChannels * length));

    // Protect against accidental overload.
    if (isinf(power) || isnan(power) || power &lt; MinPower)
        power = MinPower;

    float scale = 1 / power;

    // Calibrate to make perceived volume same as unprocessed.
    scale *= GainCalibration;

    // Scale depends on sample-rate.
    if (buffer->sampleRate())
        scale *= GainCalibrationSampleRate / buffer->sampleRate();

    // True-stereo compensation.
    if (buffer->numberOfChannels() == 4)
        scale *= 0.5;

    return scale;
}
          </code></pre>

      </div>
      </div>
      </div>

<p>
During processing, the ConvolverNode will then take this calculated <em>normalizationScale</em> value and multiply it by the result of the linear convolution
resulting from processing the input with the impulse response (represented by the <em>buffer</em>) to produce the
final output.  Or any mathematically equivalent operation may be used, such as pre-multiplying the
input by <em>normalizationScale</em>, or pre-multiplying a version of the impulse-response by <em>normalizationScale</em>.
</p>

</div>

<div id="RealtimeAnalyserNode-section" class="section">
<h2 id="RealtimeAnalyserNode">4.17. The RealtimeAnalyserNode Interface</h2>

<p>This interface represents a node which is able to provide real-time
frequency and time-domain <a href="#RealtimeAnalysis-section">analysis</a>
information. The audio stream will be passed un-processed from input to output.
</p>
<pre>    numberOfInputs  : 1
    numberOfOutputs : 1    <em>Note that this output may be left unconnected.</em>
    </pre>

<div class="block">

<div class="blockTitleDiv">
<span class="blockTitle">Web IDL</span></div>

<div class="blockContent">
<pre class="code"><code class="idl-code">

interface <dfn id="dfn-RealtimeAnalyserNode">RealtimeAnalyserNode</dfn> : AudioNode {

    <span class="comment">// Real-time frequency-domain data </span>
    void getFloatFrequencyData(Float32Array array);
    void getByteFrequencyData(Uint8Array array);

    <span class="comment">// Real-time waveform data </span>
    void getByteTimeDomainData(Uint8Array array);

    attribute unsigned long fftSize;
    readonly attribute unsigned long frequencyBinCount;

    attribute float minDecibels;
    attribute float maxDecibels;

    attribute float smoothingTimeConstant;

};
</code></pre>
</div>
</div>
</div>

<div id="attributes-ConvolverNode-section_2" class="section">
<h3 id="attributes-ConvolverNode_2">4.17.1. Attributes</h3>
<dl>
  <dt id="dfn-fftSize"><code>fftSize</code></dt>
    <dd><p>The size of the FFT used for frequency-domain analysis. This must be
      a power of two. </p>
    </dd>
</dl>
<dl>
  <dt id="dfn-frequencyBinCount"><code>frequencyBinCount</code></dt>
    <dd><p>Half the FFT size. </p>
    </dd>
</dl>
<dl>
  <dt id="dfn-minDecibels"><code>minDecibels</code></dt>
    <dd><p>The minimum power value in the scaling range for the FFT analysis
      data for conversion to unsigned byte values. </p>
    </dd>
</dl>
<dl>
  <dt id="dfn-maxDecibels"><code>maxDecibels</code></dt>
    <dd><p>The maximum power value in the scaling range for the FFT analysis
      data for conversion to unsigned byte values. </p>
    </dd>
</dl>
<dl>
  <dt id="dfn-smoothingTimeConstant"><code>smoothingTimeConstant</code></dt>
    <dd><p>A value from 0 -&gt; 1 where 0 represents no time averaging
      with the last analysis frame. </p>
    </dd>
</dl>
</div>

<h3 id="methods-and-parameters">4.17.2. Methods and Parameters</h3>
<dl>
  <dt id="dfn-getFloatFrequencyData">The <code>getFloatFrequencyData</code>
  method</dt>
    <dd><p>Copies the current frequency data into the passed floating-point
      array. If the array has fewer elements than the frequencyBinCount, the
      excess elements will be dropped. </p>
      <p>The <dfn id="dfn-array">array</dfn> parameter is where
      frequency-domain analysis data will be copied. </p>
    </dd>
</dl>
<dl>
  <dt id="dfn-getByteFrequencyData">The <code>getByteFrequencyData</code>
  method</dt>
    <dd><p>Copies the current frequency data into the passed unsigned byte
      array. If the array has fewer elements than the frequencyBinCount, the
      excess elements will be dropped. </p>
      <p>The <dfn id="dfn-array_2">array</dfn> parameter is where
      frequency-domain analysis data will be copied. </p>
    </dd>
</dl>
<dl>
  <dt id="dfn-getByteTimeDomainData">The <code>getByteTimeDomainData</code>
  method</dt>
    <dd><p>Copies the current time-domain (waveform) data into the passed
      unsigned byte array. If the array has fewer elements than the
      frequencyBinCount, the excess elements will be dropped. </p>
      <p>The <dfn id="dfn-array_3">array</dfn> parameter is where time-domain
      analysis data will be copied. </p>
    </dd>
</dl>

<div id="AudioChannelSplitter-section" class="section">
<h2 id="AudioChannelSplitter">4.18. The AudioChannelSplitter Interface</h2>

<p>The <code>AudioChannelSplitter</code> is for use in more advanced
applications and would often be used in conjunction with <a
href="#AudioChannelMerger-section"><code>AudioChannelMerger</code></a>. </p>
<pre>    numberOfInputs  : 1
    numberOfOutputs : Variable N (defaults to 6) // number of "active" (non-silent) outputs is determined by number of channels in the input
    </pre>

<p>This interface represents an AudioNode for accessing the individual channels
of an audio stream in the routing graph. It has a single input, and a number of
"active" outputs which equals the number of channels in the input audio stream.
For example, if a stereo input is connected to an
<code>AudioChannelSplitter</code> then the number of active outputs will be two
(one from the left channel and one from the right). There are always a total
number of N outputs (determined by the <code>numberOfOutputs</code> parameter to the AudioContext method <code>createChannelSplitter()</code>),
 The default number is 6 if this value is not provided. Any outputs
which are not "active" will output silence and would typically not be connected
to anything. </p>

<h3 id="example-1">Example:</h3>
<img alt="channel splitter" src="images/channel-splitter.png" /> 

<p>Please note that in this example, the splitter does <b>not</b> interpret the channel identities (such as left, right, etc.), but
simply splits out channels in the order that they are input.</p>

<p>One application for <code>AudioChannelSplitter</code> is for doing "matrix
mixing" where individual gain control of each channel is desired. </p>

<div class="block">

<div class="blockTitleDiv">
<span class="blockTitle">Web IDL</span></div>

<div class="blockContent">
<pre class="code"><code class="idl-code">

interface <dfn id="dfn-AudioChannelSplitter">AudioChannelSplitter</dfn> : AudioNode {

};
</code></pre>
</div>
</div>
</div>

<div id="AudioChannelMerger-section" class="section">
<h2 id="AudioChannelMerger">4.19. The AudioChannelMerger Interface</h2>

<p>The <code>AudioChannelMerger</code> is for use in more advanced applications
and would often be used in conjunction with <a
href="#AudioChannelSplitter-section"><code>AudioChannelSplitter</code></a>. </p>
<pre>    numberOfInputs  : Variable N (default to 6)  // number of connected inputs may be less than this
    numberOfOutputs : 1
    </pre>

<p>This interface represents an AudioNode for combining channels from multiple
audio streams into a single audio stream. It has a variable number of inputs (defaulting to 6), but not all of them
need be connected. There is a single output whose audio stream has a number of
channels equal to the sum of the numbers of channels of all the connected
inputs. For example, if an <code>AudioChannelMerger</code> has two connected
inputs (both stereo), then the output will be four channels, the first two from
the first input and the second two from the second input. In another example
with two connected inputs (both mono), the output will be two channels
(stereo), with the left channel coming from the first input and the right
channel coming from the second input. </p>

<h3 id="example-2">Example:</h3>
<img alt="channel merger" src="images/channel-merger.png" /> 

<p>Please note that in this example, the merger does <b>not</b> interpret the channel identities (such as left, right, etc.), but
simply combines channels in the order that they are input.</p>


<p>Be aware that it is possible to connect an <code>AudioChannelMerger</code>
in such a way that it outputs an audio stream with a large number of channels
greater than the maximum supported by the audio hardware. In this case where such an output is connected
to the AudioContext .destination (the audio hardware), then the extra channels will be ignored.
Thus, the <code>AudioChannelMerger</code> should be used in situations where the number
of channels is well understood. </p>

<div class="block">

<div class="blockTitleDiv">
<span class="blockTitle">Web IDL</span></div>

<div class="blockContent">
<pre class="code"><code class="idl-code">

interface <dfn id="dfn-AudioChannelMerger">AudioChannelMerger</dfn> : AudioNode {

};
</code></pre>
</div>
</div>
</div>

<div id="DynamicsCompressorNode-section" class="section">
<h2 id="DynamicsCompressorNode">4.20. The DynamicsCompressorNode Interface</h2>

<p>DynamicsCompressorNode is an AudioNode processor implementing a dynamics
compression effect. </p>

<p>Dynamics compression is very commonly used in musical production and game
audio. It lowers the volume of the loudest parts of the signal and raises the
volume of the softest parts. Overall, a louder, richer, and fuller sound can be
achieved. It is especially important in games and musical applications where
large numbers of individual sounds are played simultaneous to control the
overall signal level and help avoid clipping (distorting) the audio output to
the speakers. </p>
<pre>    numberOfInputs  : 1
    numberOfOutputs : 1
    </pre>

<div class="block">

<div class="blockTitleDiv">
<span class="blockTitle">Web IDL</span></div>

<div class="blockContent">
<pre class="code">    			<code class="idl-code">

interface <dfn id="dfn-DynamicsCompressorNode">DynamicsCompressorNode</dfn> : AudioNode {

    readonly attribute AudioParam threshold; // in Decibels
    readonly attribute AudioParam knee; // in Decibels
    readonly attribute AudioParam ratio; // unit-less
    readonly attribute AudioParam reduction; // in Decibels
    readonly attribute AudioParam attack; // in Seconds
    readonly attribute AudioParam release; // in Seconds

};
</code>
</pre>
</div>
</div>

<div id="attributes-DynamicsCompressorNode-section" class="section">
<h3 id="attributes-DynamicsCompressorNode">4.20.1. Attributes</h3>
<p>
All parameters are <em>k-rate</em>
</p>

<dl>
  <dt id="dfn-threshold"><code>threshold</code></dt>
    <dd><p>The decibel value above which the compression will start taking
      effect. </p>
    </dd>
</dl>
<dl>
  <dt id="dfn-knee"><code>knee</code></dt>
    <dd><p>A decibel value representing the range above the threshold where the
      curve smoothly transitions to the "ratio" portion. </p>
    </dd>
</dl>
<dl>
  <dt id="dfn-ratio"><code>ratio</code></dt>
    <dd><p>The amount of dB change in input for a 1 dB change in output. </p>
    </dd>
</dl>
<dl>
  <dt id="dfn-reduction"><code>reduction</code></dt>
    <dd><p>A read-only decibel value for metering purposes, representing the
      current amount of gain reduction that the compressor is applying to the
      signal. </p>
    </dd>
</dl>
<dl>
  <dt id="dfn-attack"><code>attack</code></dt>
    <dd><p>The amount of time to reduce the gain by 10dB. </p>
    </dd>
</dl>
<dl>
  <dt id="dfn-release"><code>release</code></dt>
    <dd><p>The amount of time to increase the gain by 10dB. </p>
    </dd>
</dl>
</div>
</div>

<div id="BiquadFilterNode-section" class="section">
<h2 id="BiquadFilterNode">4.21. The BiquadFilterNode Interface</h2>

<p>BiquadFilterNode is an AudioNode processor implementing very common
low-order filters. </p>

<p>Low-order filters are the building blocks of basic tone controls (bass, mid,
treble), graphic equalizers, and more advanced filters. Multiple
BiquadFilterNode filters can be combined to form more complex filters. The
filter parameters such as "frequency" can be changed over time for filter
sweeps, etc. Each BiquadFilterNode can be configured as one of a number of
common filter types as shown in the IDL below.  The default filter type
is LOWPASS </p>
<pre>    numberOfInputs  : 1
    numberOfOutputs : 1
    </pre>

<div class="block">

<div class="blockTitleDiv">
<span class="blockTitle">Web IDL</span></div>

<div class="blockContent">
<pre class="code"><code class="idl-code">

interface <dfn id="dfn-BiquadFilterNode">BiquadFilterNode</dfn> : AudioNode {

    // Filter type.
    const unsigned short LOWPASS = 0;
    const unsigned short HIGHPASS = 1;
    const unsigned short BANDPASS = 2;
    const unsigned short LOWSHELF = 3;
    const unsigned short HIGHSHELF = 4;
    const unsigned short PEAKING = 5;
    const unsigned short NOTCH = 6;
    const unsigned short ALLPASS = 7;

    attribute unsigned short type;
    readonly attribute AudioParam frequency; // in Hertz
    readonly attribute AudioParam Q; // Quality factor
    readonly attribute AudioParam gain; // in Decibels

    void getFrequencyResponse(Float32Array frequencyHz,
                              Float32Array magResponse,
                              Float32Array phaseResponse);

};
</code></pre>
</div>
</div>
</div>

<p>The filter types are briefly described below. We note that all of these
filters are very commonly used in audio processing. In terms of implementation,
they have all been derived from standard analog filter prototypes. For more
technical details, we refer the reader to the excellent <a
href="http://www.musicdsp.org/files/Audio-EQ-Cookbook.txt">reference</a> by
Robert Bristow-Johnson.</p>

<p>
All parameters are <em>k-rate</em>
</p>

<div id="BiquadFilterNode-description-section" class="section">
<h3 id="BiquadFilterNode-description">4.21.1 LOWPASS</h3>

<p>A <a href="http://en.wikipedia.org/wiki/Low-pass_filter">lowpass filter</a>
allows frequencies below the cutoff frequency to pass through and attenuates
frequencies above the cutoff. LOWPASS implements a standard second-order
resonant lowpass filter with 12dB/octave rolloff.</p>

<blockquote>
  <dl>
    <dt>frequency</dt>
      <dd>The cutoff frequency above which the frequencies are attenuated</dd>
    <dt><a href="http://en.wikipedia.org/wiki/Q_factor">Q</a></dt>
      <dd>Controls how peaked the response will be at the cutoff frequency. A
        large value makes the response more peaked.</dd>
    <dt>gain</dt>
      <dd>Not used in this filter type</dd>
  </dl>
</blockquote>

<h3 id="HIGHPASS">4.21.2 HIGHPASS</h3>

<p>A <a href="http://en.wikipedia.org/wiki/High-pass_filter">highpass
filter</a> is the opposite of a lowpass filter. Frequencies above the cutoff
frequency are passed through, but frequencies below the cutoff are attenuated.
HIGHPASS implements a standard second-order resonant highpass filter with
12dB/octave rolloff.</p>

<blockquote>
  <dl>
    <dt>frequency</dt>
      <dd>The cutoff frequency below which the frequencies are attenuated</dd>
    <dt><a href="http://en.wikipedia.org/wiki/Q_factor">Q</a></dt>
      <dd>Controls how peaked the response will be at the cutoff frequency. A
        large value makes the response more peaked.</dd>
    <dt>gain</dt>
      <dd>Not used in this filter type</dd>
  </dl>
</blockquote>

<h3 id="BANDPASS">4.21.3 BANDPASS</h3>

<p>A <a href="http://en.wikipedia.org/wiki/Band-pass_filter">bandpass
filter</a> allows a range of frequencies to pass through and attenuates the
frequencies below and above this frequency range. BANDPASS implements a
second-order bandpass filter.</p>

<blockquote>
  <dl>
    <dt>frequency</dt>
      <dd>The center of the frequency band</dd>
    <dt><a href="http://en.wikipedia.org/wiki/Q_factor">Q</a></dt>
      <dd>Controls the width of the band. The width becomes narrower as the Q
        value increases.</dd>
    <dt>gain</dt>
      <dd>Not used in this filter type</dd>
  </dl>
</blockquote>

<h3 id="LOWSHELF">4.21.4 LOWSHELF</h3>

<p>The lowshelf filter allows all frequencies through, but adds a boost (or
attenuation) to the lower frequencies. LOWSHELF implements a second-order
lowshelf filter.</p>

<blockquote>
  <dl>
    <dt>frequency</dt>
      <dd>The upper limit of the frequences where the boost (or attenuation) is
        applied.</dd>
    <dt><a href="http://en.wikipedia.org/wiki/Q_factor">Q</a></dt>
      <dd>Not used in this filter type.</dd>
    <dt>gain</dt>
      <dd>The boost, in dB, to be applied. If the value is negative, the
        frequencies are attenuated.</dd>
  </dl>
</blockquote>

<h3 id="L16352">4.21.5 HIGHSHELF</h3>

<p>The highshelf filter is the opposite of the lowshelf filter and allows all
frequencies through, but adds a boost to the higher frequencies. HIGHSHELF
implements a second-order highshelf filter</p>

<blockquote>
  <dl>
    <dt>frequency</dt>
      <dd>The lower limit of the frequences where the boost (or attenuation) is
        applied.</dd>
    <dt><a href="http://en.wikipedia.org/wiki/Q_factor">Q</a></dt>
      <dd>Not used in this filter type.</dd>
    <dt>gain</dt>
      <dd>The boost, in dB, to be applied. If the value is negative, the
        frequencies are attenuated.</dd>
  </dl>
</blockquote>

<h3 id="PEAKING">4.21.6 PEAKING</h3>

<p>The peaking filter allows all frequencies through, but adds a boost (or
attenuation) to a range of frequencies. </p>

<blockquote>
  <dl>
    <dt>frequency</dt>
      <dd>The center frequency of where the boost is applied.</dd>
    <dt><a href="http://en.wikipedia.org/wiki/Q_factor">Q</a></dt>
      <dd>Controls the width of the band of frequencies that are boosted. A
        large value implies a narrow width.</dd>
    <dt>gain</dt>
      <dd>The boost, in dB, to be applied. If the value is negative, the
        frequencies are attenuated.</dd>
  </dl>
</blockquote>

<h3 id="NOTCH">4.21.7 NOTCH</h3>

<p>The notch filter (also known as a <a
href="http://en.wikipedia.org/wiki/Band-stop_filter">band-stop or
band-rejection filter</a>) is the opposite of a bandpass filter. It allows all
frequencies through, except for a set of frequencies.</p>

<blockquote>
  <dl>
    <dt>frequency</dt>
      <dd>The center frequency of where the notch is applied.</dd>
    <dt><a href="http://en.wikipedia.org/wiki/Q_factor">Q</a></dt>
      <dd>Controls the width of the band of frequencies that are attenuated. A
        large value implies a narrow width.</dd>
    <dt>gain</dt>
      <dd>Not used in this filter type.</dd>
  </dl>
</blockquote>

<h3 id="ALLPASS">4.21.8 ALLPASS</h3>

<p>An <a
href="http://en.wikipedia.org/wiki/All-pass_filter#Digital_Implementation">allpass
filter</a> allows all frequencies through, but changes the phase relationship
between the various frequencies. ALLPASS implements a second-order allpass
filter</p>

<blockquote>
  <dl>
    <dt>frequency</dt>
      <dd>The frequency where the center of the phase transition occurs. Viewed
        another way, this is the frequency with maximal <a
        href="http://en.wikipedia.org/wiki/Group_delay">group delay</a>.</dd>
    <dt><a href="http://en.wikipedia.org/wiki/Q_factor">Q</a></dt>
      <dd>Controls how sharp the phase transition is at the center frequency. A
        larger value implies a sharper transition and a larger group delay.</dd>
    <dt>gain</dt>
      <dd>Not used in this filter type.</dd>
  </dl>
</blockquote>

<h3 id="Methods">4.21.9. Methods</h3>
<dl>
  <dt id="dfn-getFrequencyResponse">The <code>getFrequencyResponse</code>
  method</dt>
    <dd><p>Given the current filter parameter settings, calculates the
      frequency response for the specified frequencies. </p>
      <p>The <dfn id="dfn-frequencyHz">frequencyHz</dfn> parameter specifies an
      array of frequencies at which the response values will be calculated.</p>
      <p>The <dfn id="dfn-magResponse">magResponse</dfn> parameter specifies an
      output array receiving the linear magnitude response values.</p>
      <p>The <dfn id="dfn-phaseResponse">phaseResponse</dfn> parameter
      specifies an output array receiving the phase response values in
      radians.</p>
    </dd>
</dl>
</div>

<div id="WaveShaperNode-section" class="section">
<h2 id="WaveShaperNode">4.22. The WaveShaperNode Interface</h2>

<p>WaveShaperNode is an AudioNode processor implementing non-linear distortion
effects. </p>

<p>Non-linear waveshaping distortion is commonly used for both subtle
non-linear warming, or more obvious distortion effects. Arbitrary non-linear
shaping curves may be specified. </p>
<pre>    numberOfInputs  : 1
    numberOfOutputs : 1
    </pre>

<div class="block">

<div class="blockTitleDiv">
<span class="blockTitle">Web IDL</span></div>

<div class="blockContent">
<pre class="code"><code class="idl-code">

interface <dfn id="dfn-WaveShaperNode">WaveShaperNode</dfn> : AudioNode {

    attribute Float32Array curve;

};
</code></pre>
</div>
</div>

<div id="attributes-WaveShaperNode-section" class="section">
<h3 id="attributes-WaveShaperNode">4.22.1. Attributes</h3>
<dl>
  <dt id="dfn-curve"><code>curve</code></dt>
    <dd><p>The shaping curve used for the waveshaping effect. The input signal
      is nominally within the range -1 -&gt; +1. Each input sample within this
      range will index into the shaping curve with a signal level of zero
      corresponding to the center value of the curve array. Any sample value
      less than -1 will correspond to the first value in the curve array. Any
      sample value less greater than +1 will correspond to the last value in
      the curve array. </p>
    </dd>
</dl>
</div>
</div>

<div id="Oscillator-section" class="section">
<h2 id="Oscillator">4.23. The Oscillator Interface</h2>

<p>Oscillator represents an audio source generating a periodic waveform. It can be set to
a few commonly used waveforms. Additionally, it can be set to an arbitrary periodic
waveform through the use of a <a href="#WaveTable-section"><code>WaveTable</code></a> object. </p>

<p>Oscillators are common foundational building blocks in audio synthesis.  An Oscillator will start emitting sound at the time
specified by the <code>noteOn()</code> method. </p>

<p>
Mathematically speaking, a <em>continuous-time</em> periodic waveform can have very high (or infinitely high) frequency information when considered
in the frequency domain.  When this waveform is sampled as a discrete-time digital audio signal at a particular sample-rate,
then care must be taken to discard (filter out) the high-frequency information higher than the <em>Nyquist</em> frequency (half the sample-rate)
before converting the waveform to a digital form.  If this is not done, then <em>aliasing</em> of higher frequencies (than the Nyquist frequency) will fold
back as mirror images into frequencies lower than the Nyquist frequency.  In many cases this will cause audibly objectionable artifacts.
This is a basic and well understood principle of audio DSP.
</p>

<p>
There are several practical approaches that an implementation may take to avoid this aliasing.
But regardless of approach, the <em>idealized</em> discrete-time digital audio signal is well defined mathematically.
The trade-off for the implementation is a matter of implementation cost (in terms of CPU usage) versus fidelity to
achieving this ideal.
</p>

<p>
It is expected that an implementation will take some care in achieving this ideal, but it is reasonable to consider lower-quality,
less-costly approaches on lower-end hardware.
</p>

<pre>    numberOfInputs  : 0
    numberOfOutputs : 1
    </pre>

<div class="block">

<div class="blockTitleDiv">
<span class="blockTitle">Web IDL</span></div>

<div class="blockContent">
<pre class="code"><code class="idl-code">

interface <dfn id="dfn-Oscillator">Oscillator</dfn> : AudioSourceNode {

    // Type constants.
    const unsigned short SINE = 0;
    const unsigned short SQUARE = 1;
    const unsigned short SAWTOOTH = 2;
    const unsigned short TRIANGLE = 3;
    const unsigned short CUSTOM = 4;

    attribute unsigned short type;

    const unsigned short UNSCHEDULED_STATE = 0;
    const unsigned short SCHEDULED_STATE = 1;
    const unsigned short PLAYING_STATE = 2;
    const unsigned short FINISHED_STATE = 3;

    readonly attribute unsigned short playbackState;

    readonly attribute AudioParam frequency; // in Hertz
    readonly attribute AudioParam detune; // in Cents

    void noteOn(double when);
    void noteOff(double when);
    void setWaveTable(WaveTable waveTable);

};
</code></pre>
</div>
</div>

<div id="attributes-Oscillator-section" class="section">
<h3 id="attributes-Oscillator">4.23.1. Attributes</h3>
<dl>
  <dt id="dfn-type"><code>type</code></dt>
    <dd><p>The shape of the periodic waveform.  It may directly be set to any of the type constant values except for CUSTOM.
    The <a href="#dfn-setWaveTable"><code>setWaveTable()</code></a> method can be used to set a custom waveform, which results in this attribute
    being set to CUSTOM. </p>
    </dd>
</dl>
<dl>
  <dt id="dfn-playbackState"><code>playbackState</code></dt>
    <dd><p>defined as in <a href="#AudioBufferSourceNode-section"><code>AudioBufferSourceNode</code></a>. </p>
    </dd>
</dl>

<dl>
  <dt id="dfn-frequency"><code>frequency</code></dt>
    <dd><p>The frequency (in Hertz) of the periodic waveform. This parameter is <em>a-rate</em> </p>
    </dd>
</dl>
<dl>
  <dt id="dfn-detune"><code>detune</code></dt>
    <dd><p>A detuning value (in Cents) which will offset the <code>frequency</code> by the given amount.
     This parameter is <em>a-rate</em> </p>
    </dd>
</dl>
</div>
</div>

<div id="methodsandparams-Oscillator-section" class="section">
<h3 id="methodsandparams-Oscillator">4.23.2. Methods and Parameters</h3>
<dl>
  <dt id="dfn-setWaveTable">The <code>setWaveTable</code>
  method</dt>
    <dd><p>Sets an arbitrary custom periodic waveform given a <a href="#WaveTable-section"><code>WaveTable</code></a>.</p>
    </dd>
</dl>
<dl>
  <dt id="dfn-noteOn-AudioBufferSourceNode">The <code>noteOn</code>
  method</dt>
    <dd><p>defined as in <a href="#AudioBufferSourceNode-section"><code>AudioBufferSourceNode</code></a>. </p>
    </dd>
</dl>
<dl>
  <dt id="dfn-noteOff-AudioBufferSourceNode">The <code>noteOff</code>
  method</dt>
    <dd><p>defined as in <a href="#AudioBufferSourceNode-section"><code>AudioBufferSourceNode</code></a>. </p>
    </dd>
</dl>
</div>


<div id="WaveTable-section" class="section">
<h2 id="WaveTable">4.24. The WaveTable Interface</h2>

<p>WaveTable represents an arbitrary periodic waveform to be used with an <a href="#Oscillator-section"><code>Oscillator</code></a>.
Please see <a href="#dfn-createWaveTable">createWaveTable()</a> and <a href="#dfn-setWaveTable">setWaveTable()</a> and for more details. </p>

<div class="block">

<div class="blockTitleDiv">
<span class="blockTitle">Web IDL</span></div>

<div class="blockContent">
<pre class="code"><code class="idl-code">

interface <dfn id="dfn-WaveTable">WaveTable</dfn> {

};
</code></pre>
</div>
</div>
</div>

<div id="MediaStreamAudioSourceNode-section" class="section">
<h2 id="MediaStreamAudioSourceNode">4.25. The MediaStreamAudioSourceNode
Interface</h2>

<p>This interface represents an audio source from a <code>MediaStream</code>.
The first <code>AudioMediaStreamTrack</code> from the <code>MediaStream</code> will be
used as a source of audio.</p>
<pre>    numberOfInputs  : 0
    numberOfOutputs : 1
    </pre>

<div class="block">

<div class="blockTitleDiv">
<span class="blockTitle">Web IDL</span></div>

<div class="blockContent">
<pre class="code"><code class="idl-code">

interface <dfn id="dfn-MediaStreamAudioSourceNode">MediaStreamAudioSourceNode</dfn> : AudioSourceNode {

};
</code></pre>
</div>
</div>
</div>


<div id="AudioElementIntegration-section" class="section">
<h2 id="AudioElementIntegration">5. Integration with the <code>audio</code> and
<code>video</code> elements</h2>

<p>A <a
href="#MediaElementAudioSourceNode-section"><code>MediaElementAudioSourceNode</code></a>
can be created from an HTMLMediaElement using an AudioContext method. </p>

<div class="block">

<div class="blockTitleDiv">
<span class="blockTitle">ECMAScript</span></div>

<div class="blockContent">
<pre class="code"><code class="es-code"> 
var mediaElement = document.getElementById('mediaElementID');
var sourceNode = context.createMediaElementSource(mediaElement);
sourceNode.connect(filterNode);</code></pre>
</div>
</div>
</div>

<div id="MixerGainStructure-section" class="section">
<h2 id="MixerGainStructure">6. Mixer Gain Structure</h2>

<h3 id="background">Background</h3>

<p>One of the most important considerations when dealing with audio processing
graphs is how to adjust the gain (volume) at various points. For example, in a
standard mixing board model, each input bus has pre-gain, post-gain, and
send-gains. Submix and master out busses also have gain control. The gain
control described here can be used to implement standard mixing boards as well
as other architectures. </p>

<div id="SummingJunction-section" class="section">
<h3 id="SummingJunction">Summing Inputs</h3>
</div>

<p>The inputs to <a href="#AudioNode-section"><code>AudioNodes</code></a> have
the ability to accept connections from multiple outputs. The input then acts as
a unity gain summing junction with each output signal being added with the
others: </p>
<img alt="unity gain summing junction"
src="images/unity-gain-summing-junction.png" /> 

<p>In cases where the channel layouts of the outputs do not match, an <a
href="#UpMix-section">up-mix</a> will occur to the highest number of channels.
</p>

<h3 id="gain-Control">Gain Control</h3>

<p>But many times, it's important to be able to control the gain for each of
the output signals. The <a
href="#AudioGainNode-section"><code>AudioGainNode</code></a> gives this
control: </p>
<img alt="mixer architecture new" src="images/mixer-architecture-new.png" /> 

<p>Using these two concepts of unity gain summing junctions and AudioGainNodes,
it's possible to construct simple or complex mixing scenarios. </p>

<h3 id="Example-mixer-with-send-busses">Example: Mixer with Send Busses</h3>

<p>In a routing scenario involving multiple sends and submixes, explicit
control is needed over the volume or "gain" of each connection to a mixer. Such
routing topologies are very common and exist in even the simplest of electronic
gear sitting around in a basic recording studio. </p>

<p>Here's an example with two send mixers and a main mixer. Although possible,
for simplicity's sake, pre-gain control and insert effects are not illustrated:
</p>
<img alt="mixer gain structure" src="images/mixer-gain-structure.png" /> 

<p>This diagram is using a shorthand notation where "send 1", "send 2", and
"main bus" are actually inputs to AudioNodes, but here are represented as
summing busses, where the intersections g2_1, g3_1, etc. represent the "gain"
or volume for the given source on the given mixer. In order to expose this
gain, an <a href="#dfn-AudioGainNode"><code>AudioGainNode</code></a> is used:
</p>

<p>Here's how the above diagram could be constructed in JavaScript: </p>

<div class="example">

<div class="exampleHeader">
Example</div>

<div class="block">

<div class="blockTitleDiv">
<span class="blockTitle">ECMAScript</span></div>

<div class="blockContent">
<pre class="code"><code class="es-code"> 

var context = 0;
var compressor = 0;
var reverb = 0;
var delay = 0;
var s1 = 0;
var s2 = 0;

var source1 = 0;
var source2 = 0;
var g1_1 = 0;
var g2_1 = 0;
var g3_1 = 0;
var g1_2 = 0;
var g2_2 = 0;
var g3_2 = 0;

<span class="comment">// Setup routing graph </span>
function setupRoutingGraph() {
    context = new AudioContext();

    compressor = context.createDynamicsCompressor();

    <span class="comment">// Send1 effect </span>
    reverb = context.createConvolver();
    <span class="comment">// Convolver impulse response may be set here or later </span>

    <span class="comment">// Send2 effect </span>
    delay = context.createDelayNode();

    <span class="comment">// Connect final compressor to final destination </span>
    compressor.connect(context.destination);

    <span class="comment">// Connect sends 1 &amp; 2 through effects to main mixer </span>
    s1 = context.createGainNode();
    reverb.connect(s1);
    s1.connect(compressor);
    
    s2 = context.createGainNode();
    delay.connect(s2);
    s2.connect(compressor);

    <span class="comment">// Create a couple of sources </span>
    source1 = context.createBufferSource();
    source2 = context.createBufferSource();
    source1.buffer = manTalkingBuffer;
    source2.buffer = footstepsBuffer;

    <span class="comment">// Connect source1 </span>
    g1_1 = context.createGainNode();
    g2_1 = context.createGainNode();
    g3_1 = context.createGainNode();
    source1.connect(g1_1);
    source1.connect(g2_1);
    source1.connect(g3_1);
    g1_1.connect(compressor);
    g2_1.connect(reverb);
    g3_1.connect(delay);

    <span class="comment">// Connect source2 </span>
    g1_2 = context.createGainNode();
    g2_2 = context.createGainNode();
    g3_2 = context.createGainNode();
    source2.connect(g1_2);
    source2.connect(g2_2);
    source2.connect(g3_2);
    g1_2.connect(compressor);
    g2_2.connect(reverb);
    g3_2.connect(delay);

    <span class="comment">// We now have explicit control over all the volumes g1_1, g2_1, ..., s1, s2 </span>
    g2_1.gain.value = 0.2; <span class="comment"> // For example, set source1 reverb gain </span>

    <span class="comment"> // Because g2_1.gain is of type "AudioGain" which is an "AudioParam", </span>
    <span class="comment"> // an automation curve could also be attached to it. </span>
    <span class="comment"> // A "mixing board" UI could be created in canvas or WebGL controlling these gains. </span>
}

 </code></pre>
</div>
</div>
</div>
</div>
<br />


<div id="DynamicLifetime-section">
<h2 id="DynamicLifetime">7. Dynamic Lifetime</h2>

<h3 id="DynamicLifetime-background">Background</h3>

<p class="norm">This section is informative. Please see <a href="#lifetime-AudioContext">AudioContext lifetime</a>
and <a href="#lifetime-AudioNode">AudioNode lifetime</a>  for normative requirements
</p>

<p>In addition to allowing the creation of static routing configurations, it
should also be possible to do custom effect routing on dynamically allocated
voices which have a limited lifetime. For the purposes of this discussion,
let's call these short-lived voices "notes". Many audio applications
incorporate the ideas of notes, examples being drum machines, sequencers, and
3D games with many one-shot sounds being triggered according to game play. </p>

<p>In a traditional software synthesizer, notes are dynamically allocated and
released from a pool of available resources. The note is allocated when a MIDI
note-on message is received. It is released when the note has finished playing
either due to it having reached the end of its sample-data (if non-looping), it
having reached a sustain phase of its envelope which is zero, or due to a MIDI
note-off message putting it into the release phase of its envelope. In the MIDI
note-off case, the note is not released immediately, but only when the release
envelope phase has finished. At any given time, there can be a large number of
notes playing but the set of notes is constantly changing as new notes are
added into the routing graph, and old ones are released. </p>

<p>The audio system automatically deals with tearing-down the part of the
routing graph for individual "note" events. A "note" is represented by an
<code>AudioBufferSourceNode</code>, which can be directly connected to other
processing nodes. When the note has finished playing, the context will
automatically release the reference to the <code>AudioBufferSourceNode</code>,
which in turn will release references to any nodes it is connected to, and so
on. The nodes will automatically get disconnected from the graph and will be
deleted when they have no more references. Nodes in the graph which are
long-lived and shared between dynamic voices can be managed explicitly.
Although it sounds complicated, this all happens automatically with no extra
JavaScript handling required. </p>

<h3 id="Example-DynamicLifetime">Example</h3>

<div class="example">

<div class="exampleHeader">
Example</div>
<img alt="dynamic allocation" src="images/dynamic-allocation.png" /> 

<p>The low-pass filter, panner, and second gain nodes are directly connected
from the one-shot sound. So when it has finished playing the context will
automatically release them (everything within the dotted line). If there are no
longer any JavaScript references to the one-shot sound and connected nodes,
then they will be immediately removed from the graph and deleted. The streaming
source, has a global reference and will remain connected until it is explicitly
disconnected. Here's how it might look in JavaScript: </p>

<div class="block">

<div class="blockTitleDiv">
<span class="blockTitle">ECMAScript</span></div>

<div class="blockContent">
<pre class="code"><code class="es-code"> 

var context = 0;
var compressor = 0;
var gainNode1 = 0;
var streamingAudioSource = 0;

<span class="comment">// Initial setup of the "long-lived" part of the routing graph </span> 
function setupAudioContext() {
    context = new AudioContext();

    compressor = context.createDynamicsCompressor();
    gainNode1 = context.createGainNode();

    // Create a streaming audio source.
    var audioElement = document.getElementById('audioTagID');
    streamingAudioSource = context.createMediaElementSource(audioElement);
    streamingAudioSource.connect(gainNode1);

    gainNode1.connect(compressor);
    compressor.connect(context.destination);
}

<span class="comment">// Later in response to some user action (typically mouse or key event) </span>
<span class="comment">// a one-shot sound can be played. </span>
function playSound() {
    var oneShotSound = context.createBufferSource();
    oneShotSound.buffer = dogBarkingBuffer;

    <span class="comment">// Create a filter, panner, and gain node. </span>
    var lowpass = context.createBiquadFilter();
    var panner = context.createPanner();
    var gainNode2 = context.createGainNode();

    <span class="comment">// Make connections </span>
    oneShotSound.connect(lowpass);
    lowpass.connect(panner);
    panner.connect(gainNode2);
    gainNode2.connect(compressor);

    <span class="comment">// Play 0.75 seconds from now (to play immediately pass in 0)</span>
    oneShotSound.noteOn(context.currentTime + 0.75);
}
</code></pre>
</div>
</div>
</div>
</div>


<div id="ChannelLayouts-section" class="section">
<h2 id="ChannelLayouts">8. Channel Layouts</h2>

<p>It's important to define the channel ordering (and define some
abbreviations) for different layouts. </p>

<p>The channel layouts are clear: </p>
<pre>  Mono
    0: M: mono
    
  Stereo
    0: L: left
    1: R: right
  </pre>

<p>A more advanced implementation can handle channel layouts for quad and 5.1:
</p>
<pre>  Quad
    0: L:  left
    1: R:  right
    2: SL: surround left
    3: SR: surround right

  5.1
    0: L:   left
    1: R:   right
    2: C:   center
    3: LFE: subwoofer
    4: SL:  surround left
    5: SR:  surround right
  </pre>

<p>Other layouts can also be considered. </p>
</div>

<div id="UpMix-section" class="section">
<h2 id="UpMix">9. Channel up-mixing and down-mixing</h2>
For now, only considers cases for mono, stereo, quad, 5.1. Later other channel
layouts can be defined. 

<h3 id="UpMix-sub">Up Mixing</h3>

<p>Consider what happens when converting an audio stream with a lower number of
channels to one with a higher number of channels. This can be necessary when <a
href="#SummingJunction-section">mixing several outputs together</a> where the
channel layouts differ. It can also be necessary if the rendered audio stream
is played back on a system with more channels. </p>
<pre>Mono up-mix:
    
    1 -&gt; 2 : up-mix from mono to stereo
        output.L = input;
        output.R = input;

    1 -&gt; 4 : up-mix from mono to quad
        output.L = input;
        output.R = input;
        output.SL = 0;
        output.SR = 0;

    1 -&gt; 5.1 : up-mix from mono to 5.1
        output.L = 0;
        output.R = 0;
        output.C = input; // put in center channel
        output.LFE = 0;
        output.SL = 0;
        output.SR = 0;

Stereo up-mix:

    2 -&gt; 4 : up-mix from stereo to quad
        output.L = input.L;
        output.R = input.R;
        output.SL = 0;
        output.SR = 0;

    2 -&gt; 5.1 : up-mix from stereo to 5.1
        output.L = input.L;
        output.R = input.R;
        output.C = 0;
        output.LFE = 0;
        output.SL = 0;
        output.SR = 0;

Quad up-mix:

    4 -&gt; 5.1 : up-mix from stereo to 5.1
        output.L = input.L;
        output.R = input.R;
        output.C = 0;
        output.LFE = 0;
        output.SL = input.SL;
        output.SR = input.SR;</pre>

<h3 id="down-mix">Down Mixing</h3>

<p>A down-mix will be necessary, for example, if processing 5.1 source
material, but playing back stereo. </p>
<pre>  
Mono down-mix:

    2 -&gt; 1 : stereo to mono
        output = 0.5 * (input.L + input.R);

    4 -&gt; 1 : quad to mono
        output = 0.25 * (input.L + input.R + input.SL + input.SR);

    5.1 -&gt; 1 : 5.1 to mono
        ???


Stereo down-mix:

    4 -&gt; 2 : quad to stereo
        output.L = 0.5 * (input.L + input.SL);
        output.R = 0.5 * (input.R + input.SR);

    5.1 -&gt; 2 : 5.1 to stereo
        ???</pre>
</div>

<div id="EventScheduling-section" class="section">
<h2 id="EventScheduling">10. Event Scheduling</h2>
Need more detail here, but for now: 
<ul>
  <li>Audio events such as start/stop play and volume fades can be scheduled to
    happen in a rhythmically perfect way (sample-accurate scheduling)</li>
  <li>Allows sequencing applications such as drum-machines, digital-dj mixers.
    Ultimately, it may be useful for DAW applications.</li>
  <li>Allows rhythmically accurate segueways from one section of music to
    another (as is possible with the FMOD engine).</li>
  <li>Allows scheduling of sound "grains" for granular synthesis effects.</li>
</ul>
</div>

<div id="Spatialization-section" class="section">
<h2 id="Spatialization">11. Spatialization / Panning </h2>

<h3 id="Spatialization-background">Background</h3>

<p>A common feature requirement for modern 3D games is the ability to
dynamically spatialize and move multiple audio sources in 3D space. Game audio
engines such as OpenAL, FMOD, Creative's EAX, Microsoft's XACT Audio, etc. have
this ability. </p>

<p>Using an <code>AudioPannerNode</code>, an audio stream can be spatialized or
positioned in space relative to an <code>AudioListener</code>. An <a
href="#AudioContext-section"><code>AudioContext</code></a> will contain a
single <code>AudioListener</code>. Both panners and listeners have a position
in 3D space using a right-handed cartesian coordinate system. <code>AudioPannerNode</code>
objects (representing the source stream) have an <code>orientation</code>
vector representing in which direction the sound is projecting. Additionally,
they have a <code>sound cone</code> representing how directional the sound is.
For example, the sound could be omnidirectional, in which case it would be
heard anywhere regardless of its orientation, or it can be more directional and
heard only if it is facing the listener. <code>AudioListener</code> objects
(representing a person's ears) have an <code>orientation</code> and
<code>up</code> vector representing in which direction the person is facing.
Because both the source stream and the listener can be moving, they both have a
<code>velocity</code> vector representing both the speed and direction of
movement. Taken together, these two velocities can be used to generate a
doppler shift effect which changes the pitch. </p>

<p>
During rendering, the <code>AudioPannerNode</code> calculates an <em>azimuth</em>
and <em>elevation</em>.  These values are used internally by the implementation in
order to render the spatialization effect.  See the <a href="#Spatialization-panning-algorithm">Panning Algorithm</a> section
for details of how these values are used.
</p>

<p>
The following algorithm must be used to calculate the <em>azimuth</em>
and <em>elevation</em>:
</p>

<div class="block">
<div class="blockTitleDiv">
<div class="blockContent">
<pre class="code"><code class="idl-code"> 
// Calculate the source-listener vector.
vec3 sourceListener = source.position - listener.position;

if (sourceListener.isZero()) {
    // Handle degenerate case if source and listener are at the same point.
    azimuth = 0;
    elevation = 0;
    return;
}

sourceListener.normalize();

// Align axes.
vec3 listenerFront = listener.orientation;
vec3 listenerUp = listener.up;
vec3 listenerRight = listenerFront.cross(listenerUp);
listenerRight.normalize();

vec3 listenerFrontNorm = listenerFront;
listenerFrontNorm.normalize();

vec3 up = listenerRight.cross(listenerFrontNorm);

float upProjection = sourceListener.dot(up);

vec3 projectedSource = sourceListener - upProjection * up;
projectedSource.normalize();

azimuth = 180 * acos(projectedSource.dot(listenerRight)) / PI;

// Source in front or behind the listener.
double frontBack = projectedSource.dot(listenerFrontNorm);
if (frontBack &lt; 0)
    azimuth = 360 - azimuth;

// Make azimuth relative to "front" and not "right" listener vector.
if ((azimuth >= 0) &amp;&amp; (azimuth &lt;= 270))
    azimuth = 90 - azimuth;
else
    azimuth = 450 - azimuth;

elevation = 90 - 180 * acos(sourceListener.dot(up)) / PI;

if (elevation > 90)
    elevation = 180 - elevation;
else if (elevation &lt; -90)
    elevation = -180 - elevation;
</code></pre>
</div>
</div>
</div>

<h3 id="Spatialization-panning-algorithm">Panning Algorithm</h3>

<p>
<em>mono->stereo</em> and <em>stereo->stereo</em>  panning must be supported.
<em>mono->stereo</em> processing is used when all connections to the input are mono.
Otherwise <em>stereo->stereo</em> processing is used.</p>

<p>The following algorithms must be implemented: </p>
<ul>
  <li>Equal-power (Vector-based) panning 
    <p>This is a simple and relatively inexpensive algorithm which provides
    basic, but reasonable results.  It is commonly used when panning musical sources.
    </p>
    The <em>elevation</em> value is ignored in this panning algorithm.

    <p>
    The following steps are used for processing:
    </p>
    
    <ol>

    <li>
    <p>
    The <em>azimuth</em> value is first contained to be within the range -90 &lt;= <em>azimuth</em> &lt;= +90 according to:
    </p>
    <pre>
    // Clamp azimuth to allowed range of -180 -> +180.
    azimuth = max(-180, azimuth);
    azimuth = min(180, azimuth);

    // Now wrap to range -90 -> +90.
    if (azimuth &lt; -90)
        azimuth = -180 - azimuth;
    else if (azimuth > 90)
        azimuth = 180 - azimuth;
    </pre>
    </li>
    
    <li>
    <p>
    A 0 -> 1 normalized value <em>x</em> is calculated from <em>azimuth</em> for <em>mono->stereo</em> as:
    </p>
    <pre>
    x = (azimuth + 90) / 180    
    </pre>

    <p>
    Or for <em>stereo->stereo</em> as:
    </p>
    <pre>
    if (azimuth &lt;= 0) { // from -90 -> 0
        // inputL -> outputL and "equal-power pan" inputR as in mono case
        // by transforming the "azimuth" value from -90 -> 0 degrees into the range -90 -> +90.
        x = (azimuth + 90) / 90;
    } else { // from 0 -> +90
        // inputR -> outputR and "equal-power pan" inputL as in mono case
        // by transforming the "azimuth" value from 0 -> +90 degrees into the range -90 -> +90.
        x = azimuth / 90;
    }
    </pre>
    </li>
    
    <li>
    <p>
    Left and right gain values are then calculated:
    </p>
    <pre>
    gainL = cos(0.5 * PI * x);
    gainR = sin(0.5 * PI * x);    
    </pre>
    </li>
    
    <li>
    <p>For <em>mono->stereo</em>, the output is calculated as:</p>
    <pre>
    outputL = input * gainL
    outputR = input * gainR
    </pre>
    <p>Else for <em>stereo->stereo</em>, the output is calculated as:</p>
    <pre>
    if (azimuth &lt;= 0) { // from -90 -> 0
        outputL = inputL + inputR * gainL;
        outputR = inputR * gainR;
    } else { // from 0 -> +90
        outputL = inputL * gainL;
        outputR = inputR + inputL * gainR;
    }
    </pre>
    </li>
    
    </ol>
    
    
    
  </li>
  <li><a
    href="http://en.wikipedia.org/wiki/Head-related_transfer_function">HRTF</a>
    panning (stereo only) 
    <p>This requires a set of HRTF impulse responses recorded at a variety of
    azimuths and elevations. There are a small number of open/free impulse
    responses available. The implementation requires a highly optimized
    convolution function. It is somewhat more costly than "equal-power", but
    provides a more spatialized sound. </p>
    <img alt="HRTF panner" src="images/HRTF_panner.png" /></li>
</ul>

<h3 id="Spatialization-distance-effects">Distance Effects</h3>
<p>
Sounds which are closer are louder, while sounds further away are quieter.
Exactly <em>how</em> a sound's volume changes according to distance from the listener
depends on the <em>distanceModel</em> attribute.
</p>


<p>
During audio rendering, a <em>distance</em> value will be calculated based on the panner and listener positions according to:
</p>
<pre>
v = panner.position - listener.position
</pre>
<pre>
distance = sqrt(dot(v, v))
</pre>

<p>
<em>distance</em> will then be used to calculate <em>distanceGain</em> which depends
on the <em>distanceModel</em> attribute.  See the <a href="#AudioPannerNode-sub">Constants</a> section for details of
how this is calculated for each distance model.
</p>
<p>As part of its processing, the <code>AudioPannerNode</code> scales/multiplies the input audio signal by <em>distanceGain</em>
to make distant sounds quieter and nearer ones louder.
</p>




<h3 id="Spatialization-sound-cones">Sound Cones</h3>

<p>The listener and each sound source have an orientation vector describing
which way they are facing. Each sound source's sound projection characteristics
are described by an inner and outer "cone" describing the sound intensity as a
function of the source/listener angle from the source's orientation vector.
Thus, a sound source pointing directly at the listener will be louder than if
it is pointed off-axis. Sound sources can also be omni-directional. </p>

<h3 id="Spatialization-doppler-shift">Doppler Shift</h3>
<ul>
  <li>Introduces a pitch shift which can realistically simulate moving
  sources.</li>
  <li>Depends on: source / listener velocity vectors, speed of sound, doppler
    factor.</li>
</ul>
</div>

<div id="Convolution-section" class="section">
<h2 id="Convolution">12. Linear Effects using Convolution</h2>

<h3 id="Convolution-background">Background</h3>

<p><a href="http://en.wikipedia.org/wiki/Convolution">Convolution</a> is a
mathematical process which can be applied to an audio signal to achieve many
interesting high-quality linear effects. Very often, the effect is used to
simulate an acoustic space such as a concert hall, cathedral, or outdoor
amphitheater. It can also be used for complex filter effects, like a muffled
sound coming from inside a closet, sound underwater, sound coming through a
telephone, or playing through a vintage speaker cabinet. This technique is very
commonly used in major motion picture and music production and is considered to
be extremely versatile and of high quality. </p>

<p>Each unique effect is defined by an <code>impulse response</code>. An
impulse response can be represented as an audio file and <a
href="#recording-impulse-responses">can be recorded</a> from a real acoustic
space such as a cave, or can be synthetically generated through a great variety
of techniques. </p>

<h3 id="Convolution-motivation">Motivation for use as a Standard</h3>

<p>A key feature of many game audio engines (OpenAL, FMOD, Creative's EAX,
Microsoft's XACT Audio, etc.) is a reverberation effect for simulating the
sound of being in an acoustic space. But the code used to generate the effect
has generally been custom and algorithmic (generally using a hand-tweaked set
of delay lines and allpass filters which feedback into each other). In nearly
all cases, not only is the implementation custom, but the code is proprietary
and closed-source, each company adding its own "black magic" to achieve its
unique quality. Each implementation being custom with a different set of
parameters makes it impossible to achieve a uniform desired effect. And the
code being proprietary makes it impossible to adopt a single one of the
implementations as a standard. Additionally, algorithmic reverberation effects
are limited to a relatively narrow range of different effects, regardless of
how the parameters are tweaked. </p>

<p>A convolution effect solves these problems by using a very precisely defined
mathematical algorithm as the basis of its processing. An impulse response
represents an exact sound effect to be applied to an audio stream and is easily
represented by an audio file which can be referenced by URL. The range of
possible effects is enormous. </p>

<h3 id="Convolution-implementation-guide">Implementation Guide</h3>
<p>
Linear convolution can be implemented efficiently.
Here are some <a href="https://dvcs.w3.org/hg/audio/raw-file/tip/webaudio/convolution.html">notes</a>
describing how it can be practically implemented.
</p>

<h3 id="Convolution-reverb-effect">Reverb Effect (with matrixing)</h3>

<p class="norm">This section is normative.</p>

<p>
In the general case the source
has N input channels, the impulse response has K channels, and the playback
system has M output channels. Thus it's a matter of how to matrix these
channels to achieve the final result.
</p>

<p>
The subset of N, M, K below must be implemented (note that the first image in the diagram is just illustrating
the general case and is not normative, while the following images are normative).
Without loss of generality, developers desiring more complex and arbitrary matrixing can use multiple <code>ConvolverNode</code>
objects in conjunction with an <code>AudioChannelMerger</code>.
</p>


<p>Single channel convolution operates on a mono audio input, using a mono
impulse response, and generating a mono output. But to achieve a more spacious sound, 2 channel audio
inputs and 1, 2, or 4 channel impulse responses will be considered. The following diagram, illustrates the
common cases for stereo playback where N and M are 1 or 2 and K is 1, 2, or 4.
</p>
<img alt="reverb matrixing" src="images/reverb-matrixing.png" /> 

<h3 id="recording-impulse-responses">Recording Impulse Responses</h3>

<p class="norm">This section is informative.</p>
<img alt="impulse response" src="images/impulse-response.png" /> <br />
<br />


<p>The most <a
href="http://pcfarina.eng.unipr.it/Public/Papers/226-AES122.pdf">modern</a> and
accurate way to record the impulse response of a real acoustic space is to use
a long exponential sine sweep. The test-tone can be as long as 20 or 30
seconds, or longer. <br />
Several recordings of the test tone played through a speaker can be made with
microphones placed and oriented at various positions in the room. It's
important to document speaker placement/orientation, the types of microphones,
their settings, placement, and orientations for each recording taken. </p>

<p>Post-processing is required for each of these recordings by performing an
inverse-convolution with the test tone, yielding the impulse response of the
room with the corresponding microphone placement. These impulse responses are
then ready to be loaded into the convolution reverb engine to re-create the
sound of being in the room. </p>

<h3 id="tools">Tools</h3>

<p>Two command-line tools have been written: <br />
<code>generate_testtones</code> generates an exponential sine-sweep test-tone
and its inverse. Another tool <code>convolve</code> was written for
post-processing. With these tools, anybody with recording equipment can record
their own impulse responses. To test the tools in practice, several recordings
were made in a warehouse space with interesting acoustics. These were later
post-processed with the command-line tools. </p>
<pre>% generate_testtones -h
Usage: generate_testtone
	[-o /Path/To/File/To/Create] Two files will be created: .tone and .inverse
	[-rate &lt;sample rate&gt;] sample rate of the generated test tones
	[-duration &lt;duration&gt;] The duration, in seconds, of the generated files
	[-min_freq &lt;min_freq&gt;] The minimum frequency, in hertz, for the sine sweep

% convolve -h
Usage: convolve input_file impulse_response_file output_file</pre>
<br />


<h3 id="recording-setup">Recording Setup</h3>
<img alt="recording setup" src="images/recording-setup.png" /> <br />
<br />
Audio Interface: Metric Halo Mobile I/O 2882 <br />
<br />
<br />
<br />
<img alt="microphones speaker" src="images/microphones-speaker.png" /> <br />
<br />
<img alt="microphone" src="images/microphone.png" /> <img alt="speaker"
src="images/speaker.png" /> <br />
<br />
Microphones: AKG 414s, Speaker: Mackie HR824 <br />
<br />
<br />


<h3 id="warehouse">The Warehouse Space</h3>
<img alt="warehouse" src="images/warehouse.png" /> <br />
<br />
</div>

<div id="JavaScriptProcessing-section" class="section">
<h2 id="JavaScriptProcessing">13. JavaScript Synthesis and Processing</h2>

<p class="norm">This section is informative.</p>

<p>The Mozilla project has conducted <a
href="https://wiki.mozilla.org/Audio_Data_API">Experiments</a> to synthesize
and process audio directly in JavaScript. This approach is interesting for a
certain class of audio processing and they have produced a number of impressive
demos. This specification includes a means of synthesizing and processing
directly using JavaScript by using a special subtype of <a
href="#AudioNode-section"><code>AudioNode</code></a> called <a
href="#JavaScriptAudioNode-section"><code>JavaScriptAudioNode</code></a>. </p>

<p>Here are some interesting examples where direct JavaScript processing can be
useful: </p>

<h3 id="custom-DSP-effects">Custom DSP Effects</h3>

<p>Unusual and interesting custom audio processing can be done directly in JS.
It's also a good test-bed for prototyping new algorithms. This is an extremely
rich area. </p>

<h3 id="educational-applications">Educational Applications</h3>

<p>JS processing is ideal for illustrating concepts in computer music synthesis
and processing, such as showing the de-composition of a square wave into its
harmonic components, FM synthesis techniques, etc. </p>

<h3 id="javaScript-performance">JavaScript Performance</h3>

<p>JavaScript has a variety of <a
href="#JavaScriptPerformance-section">performance issues</a> so it is not
suitable for all types of audio processing. The approach proposed in this
document includes the ability to perform computationally intensive aspects of
the audio processing (too expensive for JavaScript to compute in real-time)
such as multi-source 3D spatialization and convolution in optimized C++ code.
Both direct JavaScript processing and C++ optimized code can be combined due to
the APIs <a href="#ModularRouting-section">modular approach</a>. </p>

<div id="RealtimeAnalysis-section" class="section">
<h2 id="RealtimeAnalysis">14. Realtime Analysis</h2>
</div>

<div id="Performance-section" class="section">
<h2 id="Performance">15. Performance Considerations</h2>

<div id="Latency-section" class="section">
<h3 id="Latency">15.1. Latency: What it is and Why it's Important</h3>
</div>
<img alt="latency" src="images/latency.png" /> 

<p>For web applications, the time delay between mouse and keyboard events
(keydown, mousedown, etc.) and a sound being heard is important. </p>

<p>This time delay is called latency and is caused by several factors (input
device latency, internal buffering latency, DSP processing latency, output
device latency, distance of user's ears from speakers, etc.), and is
cummulative. The larger this latency is, the less satisfying the user's
experience is going to be. In the extreme, it can make musical production or
game-play impossible. At moderate levels it can affect timing and give the
impression of sounds lagging behind or the game being non-responsive. For
musical applications the timing problems affect rhythm. For gaming, the timing
problems affect precision of gameplay. For interactive applications, it
generally cheapens the users experience much in the same way that very low
animation frame-rates do. Depending on the application, a reasonable latency
can be from as low as 3-6 milliseconds to 25-50 milliseconds. </p>

<div id="Glitching-section" class="section">
<h3 id="audio-glitching">15.2. Audio Glitching</h3>
</div>

<p>Audio glitches are caused by an interruption of the normal continuous audio
stream, resulting in loud clicks and pops. It is considered to be a
catastrophic failure of a multi-media system and must be avoided. It can be
caused by problems with the threads responsible for delivering the audio stream
to the hardware, such as scheduling latencies caused by threads not having the
proper priority and time-constraints. It can also be caused by the audio DSP
trying to do more work than is possible in real-time given the CPU's speed. </p>

<h3 id="hardware-scalability">15.3. Hardware Scalability</h3>

<p>The system should gracefully degrade to allow audio processing under
resource constrained conditions without dropping audio frames. </p>

<p>First of all, it should be clear that regardless of the platform, the audio
processing load should never be enough to completely lock up the machine.
Second, the audio rendering needs to produce a clean, un-interrupted audio
stream without audible <a href="#Glitching-section">glitches</a>. </p>

<p>The system should be able to run on a range of hardware, from mobile phones
and tablet devices to laptop and desktop computers. But the more limited
compute resources on a phone device make it necessary to consider techniques to
scale back and reduce the complexity of the audio rendering. For example,
voice-dropping algorithms can be implemented to reduce the total number of
notes playing at any given time. </p>

<p>Here's a list of some techniques which can be used to limit CPU usage: </p>

<h4 id="CPU-monitoring">15.3.1. CPU monitoring</h4>

<p>In order to avoid audio breakup, CPU usage must remain below 100%. </p>

<p>The relative CPU usage can be dynamically measured for each AudioNode (and
chains of connected nodes) as a percentage of the rendering time quantum. In a
single-threaded implementation, overall CPU usage must remain below 100%. The
measured usage may be used internally in the implementation for dynamic
adjustments to the rendering. It may also be exposed through a
<code>cpuUsage</code> attribute of <code>AudioNode</code> for use by
JavaScript. </p>

<p>In cases where the measured CPU usage is near 100% (or whatever threshold is
considered too high), then an attempt to add additional <code>AudioNodes</code>
into the rendering graph can trigger voice-dropping. </p>

<h4 id="Voice-dropping">15.3.2. Voice Dropping</h4>

<p>Voice-dropping is a technique which limits the number of voices (notes)
playing at the same time to keep CPU usage within a reasonable range. There can
either be an upper threshold on the total number of voices allowed at any given
time, or CPU usage can be dynamically monitored and voices dropped when CPU
usage exceeds a threshold. Or a combination of these two techniques can be
applied. When CPU usage is monitored for each voice, it can be measured all the
way from the AudioSourceNode through any effect processing nodes which apply
uniquely to that voice. </p>

<p>When a voice is "dropped", it needs to happen in such a way that it doesn't
introduce audible clicks or pops into the rendered audio stream. One way to
achieve this is to quickly fade-out the rendered audio for that voice before
completely removing it from the rendering graph. </p>

<p>When it is determined that one or more voices must be dropped, there are
various strategies for picking which voice(s) to drop out of the total ensemble
of voices currently playing. Here are some of the factors which can be used in
combination to help with this decision: </p>
<ul>
  <li>Older voices, which have been playing the longest can be dropped instead
    of more recent voices. </li>
  <li>Quieter voices, which are contributing less to the overall mix may be
    dropped instead of louder ones. </li>
  <li>Voices which are consuming relatively more CPU resources may be dropped
    instead of less "expensive" voices.</li>
  <li>An AudioNode can have a <code>priority</code> attribute to help determine
    the relative importance of the voices.</li>
</ul>

<h4 id="Simplification-of-Effects-Processing">15.3.3. Simplification of Effects
Processing</h4>

<p>Most of the effects described in this document are relatively inexpensive
and will likely be able to run even on the slower mobile devices. However, the
<a href="#ConvolverNode-section">convolution effect</a> can be configured with
a variety of impulse responses, some of which will likely be too heavy for
mobile devices. Generally speaking, CPU usage scales with the length of the
impulse response and the number of channels it has. Thus, it is reasonable to
consider that impulse responses which exceed a certain length will not be
allowed to run. The exact limit can be determined based on the speed of the
device. Instead of outright rejecting convolution with these long responses, it
may be interesting to consider truncating the impulse responses to the maximum
allowed length and/or reducing the number of channels of the impulse response.
</p>

<p>In addition to the convolution effect. The <a
href="#AudioPannerNode-section"><code>AudioPannerNode</code></a> may also be
expensive if using the HRTF panning model. For slower devices, a cheaper
algorithm such as EQUALPOWER can be used to conserve compute resources. </p>

<h4 id="Sample-rate">15.3.4. Sample Rate</h4>

<p>For very slow devices, it may be worth considering running the rendering at
a lower sample-rate than normal. For example, the sample-rate can be reduced
from 44.1KHz to 22.05KHz. This decision must be made when the
<code>AudioContext</code> is created, because changing the sample-rate
on-the-fly can be difficult to implement and will result in audible glitching
when the transition is made. </p>

<h4 id="pre-flighting">15.3.5. Pre-flighting</h4>

<p>It should be possible to invoke some kind of "pre-flighting" code (through
JavaScript) to roughly determine the power of the machine. The JavaScript code
can then use this information to scale back any more intensive processing it
may normally run on a more powerful machine. Also, the underlying
implementation may be able to factor in this information in the voice-dropping
algorithm. </p>

<p><span class="ednote">TODO: add specification and more detail here </span></p>

<h4 id="Authoring-for-different-user-agents">15.3.6. Authoring for different
user agents</h4>
JavaScript code can use information about user-agent to scale back any more
intensive processing it may normally run on a more powerful machine. 

<h4 id="Scalability-of-Direct-JavaScript-Synthesis">15.3.7. Scalability of
Direct JavaScript Synthesis / Processing</h4>

<p>Any audio DSP / processing code done directly in JavaScript should also be
concerned about scalability. To the extent possible, the JavaScript code itself
needs to monitor CPU usage and scale back any more ambitious processing when
run on less powerful devices. If it's an "all or nothing" type of processing,
then user-agent check or pre-flighting should be done to avoid generating an
audio stream with audio breakup. </p>

<div id="JavaScriptPerformance-section" class="section">
<h3 id="JavaScriptPerformance">15.4. JavaScript Issues with real-time
Processing and Synthesis: </h3>
</div>
While processing audio in JavaScript, it is extremely challenging to get
reliable, glitch-free audio while achieving a reasonably low-latency,
especially under heavy processor load. 
<ul>
  <li>JavaScript is very much slower than heavily optimized C++ code and is not
    able to take advantage of SSE optimizations and multi-threading which is
    critical for getting good performance on today's processors. Optimized
    native code can be on the order of twenty times faster for processing FFTs
    as compared with JavaScript. It is not efficient enough for heavy-duty
    processing of audio such as convolution and 3D spatialization of large
    numbers of audio sources. </li>
  <li>setInterval() and XHR handling will steal time from the audio processing.
    In a reasonably complex game, some JavaScript resources will be needed for
    game physics and graphics. This creates challenges because audio rendering
    is deadline driven (to avoid glitches and get low enough latency).</li>
  <li>JavaScript does not run in a real-time processing thread and thus can be
    pre-empted by many other threads running on the system.</li>
  <li>Garbage Collection (and autorelease pools on Mac OS X) can cause
    unpredictable delay on a JavaScript thread. </li>
  <li>Multiple JavaScript contexts can be running on the main thread, stealing
    time from the context doing the processing. </li>
  <li>Other code (other than JavaScript) such as page rendering runs on the
    main thread. </li>
  <li>Locks can be taken and memory is allocated on the JavaScript thread. This
    can cause additional thread preemption. </li>
</ul>
The problems are even more difficult with today's generation of mobile devices
which have processors with relatively poor performance and power consumption /
battery-life issues. <br />
<br />


<div id="ExampleApplications-section" class="section">
<h2 id="ExampleApplications">16. Example Applications</h2>

<p class="norm">This section is informative.</p>

<p>Please see the <a
href="http://chromium.googlecode.com/svn/trunk/samples/audio/index.html">demo</a>
page for working examples. </p>

<p>Here are some of the types of applications a web audio system should be able
to support: </p>

<h3 id="basic-sound-playback">Basic Sound Playback</h3>

<p>Simple and <a href="#Latency-section"><strong>low-latency</strong></a>
playback of sound effects in response to simple user actions such as mouse
click, roll-over, key press. </p>
<br />


<h3 id="threeD-environmentse-and-games">3D Environments and Games</h3>
<img alt="quake" src="images/quake.png" /> <img alt="beach demo"
src="images/beach-demo.png" /> <br />
<br />


<p>An <a href="http://techcrunch.com/2010/04/01/google-html5-quake/">HTML5
version of Quake</a> has already been created. Audio features such as 3D
spatialization and convolution for room simulation could be used to great
effect. </p>

<p>3D environments with audio are common in games made for desktop applications
and game consoles. Imagine a 3D island environment with spatialized audio,
seagulls flying overhead, the waves crashing against the shore, the crackling
of the fire, the creaking of the bridge, and the rustling of the trees in the
wind. The sounds can be positioned naturally as one moves through the scene.
Even going underwater, low-pass filters can be tweaked for just the right
underwater sound. </p>
<br />
<br />
<img alt="box2d" src="images/box2d.png" /> <img alt="8-ball"
src="images/8-ball.png" /> <br />
<br />


<p><a href="http://www.box2d.org/">Box2D</a> is an interesting open-source
library for 2D game physics. It has various implementations, including one
based on Canvas 2D. A demo has been created with dynamic sound effects for each
of the object collisions, taking into account the velocities vectors and
positions to spatialize the sound events, and modulate audio effect parameters
such as filter cutoff. </p>

<p>A virtual pool game with multi-sampled sound effects has also been created.
</p>
<br />


<h3 id="musical-applications">Musical Applications</h3>
<img alt="garageband" src="images/garage-band.png" /> <img
alt="shiny drum machine" src="images/shiny-drum-machine.png" /> <img
alt="tonecraft" src="images/tonecraft.png" /> <br />
<br />
Many music composition and production applications are possible. Applications
requiring tight scheduling of audio events can be implemented and can be both
educational and entertaining. Drum machines, digital DJ applications, and even
timeline-based digital music production software with some of the features of
<a href="http://en.wikipedia.org/wiki/GarageBand">GarageBand</a> can be
written. <br />
<br />


<h3 id="music-visualizers">Music Visualizers</h3>
<img alt="music visualizer" src="images/music-visualizer.png" /> <br />
<br />
When combined with WebGL GLSL shaders, realtime analysis data can be presented
in entertaining ways. These can be as advanced as any found in iTunes. <br />
<br />


<h3 id="educational-applications_2">Educational Applications</h3>
<img alt="javascript processing" src="images/javascript-processing.png" /> 

<p>A variety of educational applications can be written, illustrating concepts
in music theory and computer music synthesis and processing. </p>
<br />


<h3 id="artistic-audio-exploration">Artistic Audio Exploration</h3>

<p>There are many creative possibilites for artistic sonic environments for
installation pieces. </p>
<br />
</div>

<div id="SecurityConsiderations-section" class="section">
<h2 id="SecurityConsiderations">17. Security Considerations</h2>

<p>This section is <em>informative.</em> </p>
</div>

<div id="PrivacyConsiderations-section" class="section">
<h2 id="PrivacyConsiderations">18. Privacy Considerations</h2>

<p>This section is <em>informative</em>. When giving various information on
available AudioNodes, the Web Audio API potentially exposes information on
characteristic features of the client (such as audio hardware sample-rate) to
any page that makes use of the AudioNode interface. Additionally, timing
information can be collected through the RealtimeAnalyzerNode or
JavaScriptAudioNode interface. The information could subsequently be used to
create a fingerprint of the client. </p>

<p>Currently audio input is not specified in this document, but it will involve
gaining access to the client machine's audio input or microphone. This will
require asking the user for permission in an appropriate way, probably via the
<a href="http://developers.whatwg.org/">getUserMedia()
API</a>. </p>
</div>

<div id="requirements-section" class="section">
<h2 id="requirements">19. Requirements and Use Cases</h2>

<p>Please see <a href="#ExampleApplications-section">Example Applications</a>
</p>
</div>
</div>
</div>

<div class="appendix section" id="references">
<h2 id="L17310">A.References</h2>

<div class="section" id="normative-references">
<h3 id="Normative-references">A.1 Normative references</h3>
<dl>
  <dt id="RFC2119">[RFC2119] </dt>
    <dd>S. Bradner. <a
      href="http://www.ietf.org/rfc/rfc2119.txt"><cite><span>Key words for use
      in RFCs to Indicate Requirement Levels.</span></cite></a> Internet RFC
      2119. URL: <a
      href="http://www.ietf.org/rfc/rfc2119.txt">http://www.ietf.org/rfc/rfc2119.txt</a>
    </dd>
</dl>
</div>

<div class="section" id="informative-references">
<h3 id="Informative-references">A.2 Informative references</h3>

<p>No informative references.</p>
</div>
</div>

<div class="section" id="acknowledgements">
<h2 id="L17335">B.Acknowledgements</h2>

<p>Special thanks to the W3C <a href="http://www.w3.org/2011/audio/">Audio
Working Group</a>. Members of the Working Group are (at the time of writing,
and by alphabetical order): <br />
Berkovitz, Joe (public Invited expert);Cardoso, Gabriel (INRIA);Carlson, Eric
(Apple, Inc.);Gregan, Matthew (Mozilla Foundation);Jägenstedt, Philip (Opera
Software);Kalliokoski, Jussi (public Invited expert);Lowis, Chris (British
Broadcasting Corporation);MacDonald, Alistair (W3C Invited Experts);Michel,
Thierry (W3C/ERCIM);Noble, Jer (Apple, Inc.);O'Callahan, Robert(Mozilla
Foundation);Paradis, Matthew (British Broadcasting Corporation);Raman, T.V.
(Google, Inc.);Rogers, Chris (Google, Inc.);Schepers, Doug (W3C/MIT);Shires,
Glen (Google, Inc.);Smith, Michael (W3C/Keio);Thereaux, Olivier (British
Broadcasting Corporation);Wei, James (Intel Corporation);Wilson, Chris (Google,
Inc.); </p>
</div>

<div class="section" id="ChangeLog-section">
<h2 id="ChangeLog">C. Web Audio API Change Log</h2>
<pre>
date:        Mon Aug 13 13:26:52 2012 -0700
* Integrate Thierry Michel's 3rd public working draft edits

date:        Tue Jun 26 15:56:31 2012 -0700
* add MediaStreamAudioSourceNode

date:        Mon Jun 18 13:26:21 2012 -0700
* minor formatting fix

date:        Mon Jun 18 13:19:34 2012 -0700
* Add details for azimuth/elevation calculation

date:        Fri Jun 15 17:35:27 2012 -0700
* Add equal-power-panning details

date:        Thu Jun 14 17:31:16 2012 -0700
* Add equations for distance models

date:        Wed Jun 13 17:40:49 2012 -0700
* Bug 17334: Add precise equations for AudioParam.setTargetValueAtTime()

date:        Fri Jun 08 17:44:26 2012 -0700
* fix small typo

date:        Fri Jun 08 16:54:04 2012 -0700
* Bug 17413: AudioBuffers' relationship to AudioContext

date:        Fri Jun 08 16:05:45 2012 -0700
* Bug 17359: Add much more detail about ConvolverNode

date:        Fri Jun 08 12:59:29 2012 -0700
* minor formatting fix

date:        Fri Jun 08 12:57:11 2012 -0700
* Bug 17335: Add much more technical detail to setValueCurveAtTime()

date:        Wed Jun 06 16:34:43 2012 -0700
*Add much more detail about parameter automation, including an example

date:        Mon Jun 04 17:25:08 2012 -0700
* ISSUE-85: Oscillator folding considerations

date:        Mon Jun 04 17:02:20 2012 -0700
* ISSUE-45: AudioGain scale underdefined

date:        Mon Jun 04 16:40:43 2012 -0700
* ISSUE-41: AudioNode as input to AudioParam underdefined

date:        Mon Jun 04 16:14:48 2012 -0700
* ISSUE-20: Relationship to currentTime

date:        Mon Jun 04 15:48:49 2012 -0700
* ISSUE-94: Dynamic Lifetime

date:        Mon Jun 04 13:59:31 2012 -0700
* ISSUE-42: add more detail about AudioParam sampling and block processing

date:        Mon Jun 04 12:28:48 2012 -0700
* fix typo - minor edits

date:        Thu May 24 18:01:20 2012 -0700
* ISSUE-69: add implementors guide for linear convolution

date:        Thu May 24 17:35:45 2012 -0700
* ISSUE-49: better define AudioBuffer audio data access

date:        Thu May 24 17:15:29 2012 -0700
* fix small typo

date:        Thu May 24 17:13:34 2012 -0700
* ISSUE-24: define circular routing behavior

date:        Thu May 24 16:35:24 2012 -0700
* ISSUE-42: specify a-rate or k-rate for each AudioParam

date:        Fri May 18 17:01:36 2012 -0700
* ISSUE-53: noteOn and noteOff interaction

date:        Fri May 18 16:33:29 2012 -0700
* ISSUE-34: Remove .name attribute from AudioParam

date:        Fri May 18 16:27:19 2012 -0700
* ISSUE-33: Add maxNumberOfChannels attribute to AudioDestinationNode

date:        Fri May 18 15:50:08 2012 -0700
* ISSUE-19: added more info about AudioBuffer - IEEE 32-bit

date:        Fri May 18 15:37:27 2012 -0700
* ISSUE-29: remove reference to webkitAudioContext

date:        Fri Apr 27 12:36:54 2012 -0700
* fix two small typos reported by James Wei

date:        Tue Apr 24 12:27:11 2012 -0700
* small cleanup to AudioChannelSplitter and AudioChannelMerger

date:        Tue Apr 17 11:35:56 2012 -0700
* small fix to createWaveTable()

date:        Tue Apr 13 2012
* Cleanup AudioNode connect() and disconnect() method descriptions.
* Add AudioNode connect() to AudioParam method.

date:        Tue Apr 13 2012
* Add Oscillator and WaveTable
* Define default values for optional arguments in createJavaScriptNode(), createChannelSplitter(), createChannelMerger()
* Define default filter type for BiquadFilterNode as LOWPASS

date:        Tue Apr 11 2012
* add AudioContext .activeSourceCount attribute
* createBuffer() methods can throw exceptions
* add AudioContext method createMediaElementSource()
* update AudioContext methods createJavaScriptNode() (clean up description of parameters)
* update AudioContext method createChannelSplitter() (add numberOfOutputs parameter)
* update AudioContext method createChannelMerger() (add numberOfInputs parameter)
* update description of out-of-bounds AudioParam values (exception will not be thrown)
* remove AudioBuffer .gain attribute
* remove AudioBufferSourceNode .gain attribute
* remove AudioListener .gain attribute
* add AudioBufferSourceNode .playbackState attribute and state constants
* RealtimeAnalyserNode no longer requires its output be connected to anything
* update AudioChannelMerger section describing numberOfOutputs (defaults to 6 but settable in constructor)
* update AudioChannelSplitter section describing numberOfInputs (defaults to 6 but settable in constructor)
* add note in Spatialization sections about potential to get arbitrary convolution matrixing

date:        Tue Apr 10 2012
* Rebased editor's draft document based on edits from Thierry Michel (from 2nd public working draft).

date:        Tue Mar 13 12:13:41 2012 -0100
*  fixed all the HTML errors
*  added ids to all Headings
*  added alt attribute to all img
*  fix broken anchors
*  added a new status of this document section
*  added mandatory spec headers
*  generated a new table of content
*  added a Reference section
*  added an Acknowledgments section
*  added a Web Audio API Change Log 

date:        Fri Mar 09 15:12:42 2012 -0800
* add optional maxDelayTime argument to createDelayNode()
* add more detail about playback state to AudioBufferSourceNode
* upgrade noteOn(), noteGrainOn(), noteOff() times to double from float

date:        Mon Feb 06 16:52:39 2012 -0800
* Cleanup JavaScriptAudioNode section
* Add distance model constants for AudioPannerNode according to the OpenAL spec
* Add .normalize attribute to ConvolverNode
* Add getFrequencyResponse() method to BiquadFilterNode
* Tighten up the up-mix equations

date:        Fri Nov 04 15:40:58 2011 -0700
summary:     Add more technical detail to BiquadFilterNode description (contributed by Raymond Toy)

date:        Sat Oct 15 19:08:15 2011 -0700
summary:     small edits to the introduction

date:        Sat Oct 15 19:00:15 2011 -0700
summary:     initial commit

date:        Tue Sep 13 12:49:11 2011 -0700
summary:     add convolution reverb design document

date:        Mon Aug 29 17:05:58 2011 -0700
summary:     document the decodeAudioData() method

date:        Mon Aug 22 14:36:33 2011 -0700
summary:     fix broken MediaElementAudioSourceNode link

date:        Mon Aug 22 14:33:57 2011 -0700
summary:     refine section describing integration with HTMLMediaElement

date:        Mon Aug 01 12:05:53 2011 -0700
summary:     add Privacy section

date:        Mon Jul 18 17:53:50 2011 -0700
summary:     small update - tweak musical applications thumbnail images

date:        Mon Jul 18 17:23:00 2011 -0700
summary:     initial commit of Web Audio API specification</pre>
</div>
</body>
</html>
