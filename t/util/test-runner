#!/usr/bin/env perl
use 5.10.0;
use strict;
use warnings;
use Test::More;
use File::Basename ();
use lib File::Basename::dirname(__FILE__) . "/extlib/lib/perl5";
use t::util::Util;

BEGIN { # XXX older version of Test::More has no note()
    if(not defined &note) {
        if(-t STDOUT || $ENV{TEST_VERBOSE}) {
            *note = \&diag;
        }
        else {
            *note = sub { };
        }
    }
}

sub difflet {
    note("FYI: Test::Difflet shows you more informative output");
}

eval {
    require Data::Difflet;

    no warnings 'redefine';
    *difflet = sub {
        my($got, $expected) = @_;
        my $d = Data::Difflet->new();
        note("DIFFLET");
        note($d->compare($got, $expected));
    };
};

main(@ARGV);
exit;

sub bench {
    my ($f) = @_;
    require Time::HiRes;
    my $start = [Time::HiRes::gettimeofday()];
    my $ret = $f->();
    return ($ret, Time::HiRes::tv_interval($start));
}

sub main {
    my($file) = @_ or die "no args";

    local $TODO = 'marked as TODO' if ($file =~ /\b todo \b/xms);

    if(my @shebang = get_shebang($file)) {
        exec @shebang, $file;
    }
    elsif($file =~ m{ /run/ }xms) {
        compile_and_run($file);
    }
    elsif($file =~ m{ /compile_error/ }xms) {
        expect_compile_error($file);
    }
    elsif($file =~ m{ /lib/ }xms) {
        run_test($file);
    }
    elsif($file =~ m{ /src/ }xms) {
        run_test($file);
    }
    elsif($file =~ m{ /web/ }xms) {
        run_web_test($file);
    }
    elsif($file =~ m{ /optimize/ }xms) {
        optimize_and_compare($file, 0);
    }
    elsif($file =~ m{ /optimize-bench/ }xms) {
        optimize_and_compare($file, 1);
    }
    elsif($file =~ m{ /complete/ }xms) {
        completion_test($file);
    }
    else {
        plan tests => 1;
        local $TODO = 'unknown file';
        fail $file;
    }
}

sub get_shebang {
    my($file) = @_;

    open my($fh), "<", $file or die "Cannot open $file for reading: $!";
    my $first = <$fh>;
    close $fh;

    return grep { defined } $first =~ /\A \#\! \s* (\S+) (?: \s+ (\S+) )* /xmsg;
}

sub compile_to_run {
    my ($file, $opts) = @_;
    $opts ||= "";

    require IPC::Open3;
    require Symbol;
    my($wtr, $rdr, $err) = (Symbol::gensym(), Symbol::gensym(), Symbol::gensym());
    my $pid = IPC::Open3::open3($wtr, $rdr, $err, "bin/jsx $opts $file");
    close $wtr;
    local $/;
    my $stdout = <$rdr>;
    my $stderr = <$err>;
    close $rdr;
    close $err;
    waitpid $pid, 0;

    return if $? != 0;

    return ($stdout, $stderr);
}

sub run_compiled {
    my ($filename, $src) = @_;

    require File::Temp;

    # add the bootstrap code
    $src .= sprintf <<'EOT', $filename;
// workaround for node.js to set "JSX" to global
(function () { return this; })().JSX = JSX;
// invoke the test
try {
    JSX.require("%s")._Main.main$AS([]);
} catch (e) {
    console.log(e.message.replace(/^\[.*?\]\s*/, ""));
}
EOT

    # write to temp file
    my $temp = File::Temp->new(SUFFIX => ".js");
    $temp->print($src);
    $temp->close();

    # execute compiled node
    my $js = $ENV{JSX_RUNJS} || "node";
    open my $fh, "-|", "$js $temp"
        or die "failed to invoke node:$!";
    local $/;
    my $output = <$fh>;
    close $fh;

    return if $? != 0;

    return $output;
}

sub compile_and_run {
    my($file) = @_;

    my $opts = get_section($file, "JSX_OPTS");
    if (defined $opts) {
        chomp $opts;
        plan skip_all => 'environment variable JSX_OPTS is set'
            if $ENV{JSX_OPTS};
    }

    plan tests => 1;

    defined(my $expected = get_section($file, "EXPECTED"))
        or die "could not find EXPECTED in file:$file\n";

    # compile (FIXME support C++)
    my($src, $logs) = compile_to_run($file, $opts) or do {
        fail "compile '$file' failed: $?";
        return;
    };
    # run
    defined (my $output = run_compiled($file, $src)) or do {
        fail "failed to execute compiled script";
        return;
    };
    # compare the results
    is $output, $expected, $file or do {
        difflet([split /\n/, $output], [split /\n/, $expected]);
    };
}

sub optimize_and_compare {
    my ($file, $do_bench) = @_;

    plan skip_all => 'environment variable JSX_OPTS is set'
        if defined $ENV{JSX_OPTS};

    defined(my $expected = get_section($file, "EXPECTED"))
        or die "could not find EXPECTED in file:$file\n";
    defined(my $opts = get_section($file, "JSX_OPTS"))
        or die "cloud not find JSX_OPTS in file:$file\n";

    my $bench_least_ratio;
    if ($do_bench) {
        $bench_least_ratio = get_section($file, "BENCHMARK");
        chomp $bench_least_ratio;
        $bench_least_ratio ||= 1;
    }

    chomp $opts;

    my @optimization_flags = map { split /,/ } ($opts =~ /--optimize \s+ (\S+)/xmsg);

    plan tests => 6 + ($do_bench ? 1 : 0) + scalar(@optimization_flags);

    # compile, run, and check (wo. optimization)
    my($src, $logs) = compile_to_run($file);
    ok defined($src) && length($src) > 0,
        "compile '$file' (wo. optimization)" or return;
    is $logs, '', "... with no logs";
    my ($output, $elapsed) = bench(sub { run_compiled($file, $src) });

    is $output, $expected,
        "output of '$file' (wo. optimization)" or return;

    # compile, run, and check (w. optimization)
    my($src_optimized, $logs_optimized) = compile_to_run($file, $opts . " --optimize dump-logs");
    ok defined($src_optimized) && length($src_optimized) > 0,
        "compile '$file' (w. $opts)" or return;
    for my $flag(@optimization_flags) {
        like $logs_optimized, qr/\[ \Q$flag\E \]/xms, "... with [$flag] in logs";
    }


    ($output, my $elapsed_optimized) = bench(sub { run_compiled($file, $src_optimized) });

    is $output, $expected,
        "output of '$file' (w. $opts)" or return;

    isnt $src, $src_optimized, "generated code must be different";

    # check the times
    if ($do_bench) {
        if ($elapsed < 0.5) {
            fail "$file (unoptimized) exited too early ($elapsed seconds)";
            return;
        }
        if ($elapsed_optimized < 0.5) {
            fail "$file (optimized) exited too early ($elapsed_optimized seconds)";
            return;
        }
        my $ratio = sprintf '%.03f', ($elapsed / $elapsed_optimized) * 100 - 100;
        cmp_ok $ratio, '>=', $bench_least_ratio, "$file - at least $bench_least_ratio% faster by $opts";
        diag "$file - $ratio\% faster by optimization";
    }
}

sub expect_compile_error {
    my($file) = @_;

    plan tests => 2;


    my $err = `bin/jsx $file 2>&1`;
    isnt $?, 0, "compiling $file with non-zero status";
    unlike $err, qr/^ \s+ \b at \b \s+ \b Module \b/xms,
        "... without compiler crash";
    note $err;
}

sub completion_test {
    my($file) = @_;

    plan skip_all => 'environment variable JSX_OPTS is set'
        if defined $ENV{JSX_OPTS};

    plan tests => 2;

    defined(my $expected = get_section($file, "EXPECTED"))
        or die "could not find EXPECTED in file:$file\n";
    defined(my $opts = get_section($file, "JSX_OPTS"))
        or die "could not find JSX_OPTS in file:$file\n";

    chomp $opts;

    # run and check the output
    my $output = `bin/jsx $opts $file 2>&1`;
    if (is $?, 0, "compile $file") {
        require JSON::PP;
        my $output_data   = JSON::PP::decode_json($output);
        my $expected_data = JSON::PP::decode_json($expected);

        my $to_test = [
            map {
                my $data = {};
                for my $field(qw(word partialWord type returnType args definedClass)) {
                    $data->{$field} = $_->{$field} if exists $_->{$field} and $_->{$field};
                }
                $data;
            } @{$output_data}
        ];

        is_deeply $to_test, $expected_data, "check completion candidates of $file" or difflet($to_test, $expected_data);
    }
}

sub run_test {
    my($file) = @_;

    if (system("bin/jsx", "--test", $file) != 0) {
        fail("Cannot exec bin/jsx --test $file");
        done_testing;
    }
}

sub run_web_test {
    my($file) = @_;

    my $phantomjs = `which phantomjs`;
    if (! $phantomjs ) {
        local $TODO = "no phantomjs(1)";
        fail $file;
        done_testing;
        return;
    }
    chomp $phantomjs;

    require version;
    my $phantomjs_ver = `$phantomjs --version`;
    chomp $phantomjs_ver;
    if (version::qv($phantomjs_ver) < version::qv("1.8.0")) {
        local $TODO = "phantomjs $phantomjs_ver is too old";
        fail $file;
        done_testing;
        return;
    }
    note "phantomjs $phantomjs_ver";

    if ($ENV{SKIP_PHANTOMJS_TEST}) {
        pass "skipped";
        done_testing;
        return;
    }

    local $ENV{JSX_RUNJS} = $phantomjs;
    if (system("bin/jsx", "--executable", "commonjs", "--test", $file) != 0) {
        fail("Cannot exec bin/jsx --test $file with $phantomjs $phantomjs_ver");
        done_testing;
    }
}
# vim: set expandtab:
